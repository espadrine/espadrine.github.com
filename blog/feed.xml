<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
  <title>Espadrine’s blog</title>
  <subtitle>Let’s talk about whatever I learn!</subtitle>
  <link rel="alternate" type="text/html" href="https://espadrine.github.io/blog/"/>
  <link rel="self" type="application/atom+xml" href="https://espadrine.github.io/blog/feed.xml"/>
  <id>https://espadrine.github.io/blog/feed.xml</id>
  <updated>2018-10-26T19:12:17Z</updated>
      <entry>
        <id>https://espadrine.github.io/blog/posts/how-to-implement-go.html</id>
        <link rel="alternate" type="text/html" href="https://espadrine.github.io/blog/posts/how-to-implement-go.html"/>
        <title>How to implement Go</title>
        <published>2018-10-26T19:12:17Z</published>
        <category term="baduk"/>
<category term="ai"/>
        <content type="html">
          <![CDATA[ <h1>How to implement Go</h1>
<p>As I wanted to make an automated Go player, as I planned <a href="http://espadrine.github.io/blog/posts/a-go-browser-battle.html">on a previous
article</a>, I first needed a full implementation of the game
of Go.</p>
<p>Go is a beautiful, tremendously old game with very simple rules and yet
tremendous subtlety. Here are the rules:</p>
<ol>
<li>Each of two players, black or white, take turns either passing or placing a
stone of their color on an intersection of a 19×19 board, starting with
black.</li>
<li>A <strong>group</strong> is a set of stones that are next to each other (up, down, left or
right), or next to a stone that is in the group. A group’s <strong>liberties</strong> are
the number of disctinct empty intersections next to the group’s stones. When
a player places a stone, if it does not result in the stone’s group having no
liberties, all enemy groups that no longer have any liberties are
<strong>captured</strong>: they are removed from the board and each stone contributes one
point to the capturer.</li>
<li>A player is not allowed to place a stone if the stone’s group has no
liberties.</li>
<li>A player is not allowed to place a stone if it results, at the end of their
turn, in a board configuration that already occurred during the game. This is
known as a <strong>Ko</strong> when the configuration happened on the previous turn, and
as a <strong>Superko</strong> more generally.</li>
<li>When nobody can add stones, the player with the most stones, enclosed
intersections (aka. <strong>territory</strong>), captured stones, and <strong>Komi</strong> (an added
bonus to white to compensate for the asymmetry of who starts first), wins.</li>
</ol>
<h2>The board</h2>
<p><img src="https://thefiletree.com/metaboard/go/blog/how-to-implement-go/capture.png" alt="AlphaGo vs. AlphaGo game, where white is about to capture 66 stones." /></p>
<p>Since the board is a compact 2-dimensional space, we use an array, with each
slot containing an intersection which includes its state (empty, with a white
stone, etc.) and historical and analytical information for use by the learning
systems: whether it is a legal move, when it last received a move, whether it is
the <strong>atari</strong> liberty of a group, ie. the move that captures the group, and how
many stones it captures.</p>
<p>We also keep track of all groups on the board. Each intersection links to its
group, and the group maintains a set of its stones, and another of its
liberties. When registering a move, groups are updated. It is fast, since at
most four groups may need updating.</p>
<p>There is some logic to merge groups together, destroying the original groups,
and creating a new one that contains the union of the previous ones. It is not
particularly fast (and could likely be improved by keeping the largest group and
adding the others to it), but since merging groups does not happen on every
turn, it did not seem to matter that much for now.</p>
<p>Counting final or partial points also requires maintaining territory
information. Yet again, we use a set to keep the intersections, and each move
updates the territory information corresponding to its surroundings.</p>
<h2>Play</h2>
<p>The most complicated function is inevitably the logic for computing a move. We
must look at surrounding intersections and their groups, to assess whether the
move is a suicide (and therefore invalid), and when it captures enemy stones.</p>
<p>Most operations are essentially constant-time, apart from group merging, since
the number of impacted groups is bounded, and all operations are set updates.</p>
<h2>Superko</h2>
<p>Detecting a match into previous board configurations is probably the trickier
part of the system. Fortunately, a subtle algorithm for it already exists:
<strong>Zobrist hashing</strong>.</p>
<p>It relies on a smart hashing system, where each possible board configuration is
mapped to a unique hash. Trivial hashes would be too slow: your first guesses
for a hash probably require to read the whole board. Instead, a Zobrist hash is
similar to a rolling hash, in that it only needs a single update to account for
the forward change.</p>
<p>You start with a hash of zero for the blank board. When initializing the board,
you generate a random 64-bit value (or, when you are like me and use JS, a
32-bit integer) for each intersection on the board, and for each move that can
be made on that position (place a black stone, or place a white stone).</p>
<p>To compute the hash for a new board configuration, you take the hash of the
previous board. For every change on the board, you XOR the previous hash with
the random value associated with this particular change.</p>
<p>For instance, if you place a black stone on A19 and it captures a white stone on
B19, you will XOR the hash with the random value for “black A19”, and then XOR
it with “white B19”. <em>Fun fact</em>: it yields the same value if you do it the other
way around.</p>
<h2>Score</h2>
<p>The bulk of scoring is establishing territories. To make things simple, we
assume the game went to its final conclusion, where there are no gray zones. All
regions are either surrounded by white or black, and there are no capturable
stones left.</p>
<p>All that remains is to go through intersections in reading order, top to bottom,
left to right, and to stitch each empty spot to its neighbor territories,
potentially joining two larger territories together if necessary. Any stone that
is next to the territory gives it its color.</p>
<p>It makes counting points fairly easy: add komi, capture, stones on board, and
own territory, and the trick is done.</p>
<h2>Ongoing</h2>
<p>Having implemented the game rules is not enough to properly train bots on it.</p>
<p>For starters, we need an <strong>SGF parser</strong> to extract information about the moves
of existing games. SGF (Simple Game Format) is the main format for serializing
Go games.</p>
<p>Then, we want to support <strong>GTP</strong>: the Go Text Protocol is the most common format
for transmitting remote commands between a Go implementation and a robot player.</p>
<p>Finally, we will explore various techniques for AI design.</p>
<p>Expect fun!</p>
<script type="application/ld+json">
{ "@context": "http://schema.org",
  "@type": "BlogPosting",
  "datePublished": "2018-10-26T19:12:17Z",
  "keywords": "baduk, ai" }
</script> ]]>
        </content>
      </entry>
      <entry>
        <id>https://espadrine.github.io/blog/posts/file-system-object-storage.html</id>
        <link rel="alternate" type="text/html" href="https://espadrine.github.io/blog/posts/file-system-object-storage.html"/>
        <title>Insanities of a File System Object Storage</title>
        <published>2018-05-31T19:42:00Z</published>
        <category term="storage"/>
<category term="posix"/>
        <content type="html">
          <![CDATA[ <h1>Insanities of a File System Object Storage</h1>
<p><em>(TL;DR: I present <a href="https://www.npmjs.com/package/fsos">fsos</a>; but read on to know why.)</em></p>
<p>How do you update a file in Node.js?</p>
<p>Well, let’s browse our dear <a href="https://nodejs.org/api/fs.html">file system API</a>…</p>
<pre><code class="language-js">fs.writeFile(file, data)
</code></pre>
<p>Simple enough, isn’t it?</p>
<p>And yet, there are so many kinds of wrong in this seemingly obvious answer.</p>
<h2>POSIX</h2>
<p>Let’s first educate ourselves. Node.js’ file system API is designed to imitate
and target POSIX, a specification to etch the core Unix experience in granite.
While the main reason for the success of Unix was portability, ensuring that
userland programs could run on different machines, the three tenets of its
design were also delicious (<strong>plain text</strong> as universal interface, composable
programs via a <strong>shell</strong>, and a <strong>hierarchical file system</strong> offering a unified
interface to kernel functionality (not just data storage)).</p>
<p>Naturally, everybody stole those juicy ideas. When Richard Stallman famously
chose to write a free operating system to oppose what we would today call DRM,
he wanted Unix compatibility. When compatibility is seeked, standardization
becomes necessary. IEEE sprung into action in the form of SUS (the Single Unix
Specification), and, with Richard’s suggested name, wrote the Portable Operating
System Interface, <strong>POSIX</strong>.</p>
<p>Richard’s baby, <strong>GNU</strong>, had little impact without a proper kernel. It was a
mere collection of programs that would talk to a Unix file system if there was a
free one. Fortunately, a free one arose, birthed as <strong>Linux</strong>, and gained major
adoption thanks to its sweet mix of speed, stability, and a healthy dose of
bright experiments. When <strong>Node.js</strong> was created, Linux was the overwhelming
king of the server-side, which Node.js wanted to conquer.</p>
<p>In a way, the reason that the obvious one-liner above doesn’t work is Unix’
fault. It designed file interaction in a manner that made a lot of sense for
some uses of the file system, disregarding others. Behind the covers, each
file is a mere set of contiguous disk space (blocks, extents, or sectors) that
point to each other, so it stands to reason that appending data at the end is
probably faster than appending it at the beginning, just as it is with a diary.</p>
<p>The standard C library defined by POSIX reflects the internal design of Unix
file systems without hiding its flaws. Consequence: internally non-obvious
operations have non-obvious solutions, and non-solutions that are as tempting to
use as a chocolate cookie (up until your tongue warns you that it was in fact
raisins).</p>
<p>The most critical interface for file operations is <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html">open</a>. It returns a file
descriptor to operate the file. It takes a handful of required flags and a ton
of optional ones. Most famous amongst the required ones are <code>O_RDONLY</code> if you
will only read, <code>O_WRONLY</code> if you don’t feel like reading anymore, and <code>O_RDWR</code>
if you hate picking a side.</p>
<p>Among the optional flags, <code>O_CREAT</code> creates the file automatically if it doesn’t
exist, <code>O_TRUNC</code> empties the file, and <code>O_APPEND</code> forces you to write only at
the end. (What a coincidence that appending is both fast in file systems and
has a shortcut!)</p>
<p>However, most people use <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/fopen.html">fopen</a>, a layer on top of <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html">open</a>, which
unfortunately has very strange defaults. Instead of the flags we understand, it
has string modes that seem to mean something they do not do. Here are the
nonsensical rules.</p>
<ul>
<li><code>&quot;r&quot;</code> is the only one that prevents writing,</li>
<li>If the string has an <code>r</code>, it doesn’t create a file automatically,</li>
<li>If the string does not have a <code>+</code>, it cannot both read and write,</li>
<li>If the string has a <code>w</code>, it empties the file,</li>
<li>If the string has an <code>a</code>, all writes append to the file (finally one that
does what is on the cover!)</li>
</ul>
<p>For instance, <code>&quot;r+&quot;</code> can write, but won’t create a file automatically for some
reason.</p>
<p>The modes offered by <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/fopen.html">fopen</a> barely target what people actually do with a
file:</p>
<ol>
<li>Read a configuration file: <code>&quot;r&quot;</code>,</li>
<li>Write logs: <code>&quot;a&quot;</code>,</li>
<li>Update a whole file: nothing.</li>
</ol>
<p>For more precise operations, use <code>&quot;r+&quot;</code>. All other possibilities are most likely
bugs waiting to be found. Special mention to <code>&quot;w+&quot;</code> which empties the file it
allows you to read! In fact, the main lesson of this blog post is that <code>O_TRUNC</code>
has only one, very rare, use-case: <em>emptying a file, without removing it,
without writing to it</em>. You should essentially never use <code>&quot;w&quot;</code>.</p>
<p>Naturally, Node.js favours <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/fopen.html">fopen</a>-style modes, instead of the more elegant
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html">open</a>.</p>
<p>Naturally, its default mode for write operations is the useless <code>&quot;w&quot;</code>.</p>
<h2>Async IO</h2>
<p>Now that we have background information, let’s dig into the first issue.</p>
<p>A long-standing problem in HTTP server software is <a href="http://www.kegel.com/c10k.html">C10K</a>, ie. hitting 10k
concurrent clients to serve with a single machine. A large part of beating that
figure is dealing with how slow IO is. Fetching a file on disk takes a long
time! And by default, POSIX system calls make your program wait for the file to
be read, and your program just sits there doing nothing in the meantime, like a
passenger waiting for the bus to come.</p>
<p>Fortunately, POSIX includes a special switch to avoid waiting: <code>O_NONBLOCK</code>. It
is part of <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html">open</a>. When an IO operation is performed, you can do whatever you
want, even though the operation is not done. Later on, you can call <code>poll()</code> or
<code>select()</code> or <code>kqueue()</code> (depending on the OS you use), and learn whether the
operation is done.</p>
<p>Node.js’ <em>raison d’être</em> was completely focused on how easy JS makes
asynchronous operations. Their whole file system interface recommends using the
non-blocking API. But in some cases, it makes zero sense. So it is with
<code>fs.writeFile()</code>. It <em>never</em> does what you want. Not with the default
parameters, anyway.</p>
<p>When you use storage, you implicitly expect some level of consistency. If you
write ‘hello’ to a file which contains ‘hi’ and then immediately read from it,
you don’t expect to read ‘who is this?’ if absolutely nobody wrote to the file
in the meantime. You expect ‘hello’ — or, at least, ‘hi’. But here, you will
read neither what was in the file before, nor what you wrote in it.</p>
<pre><code class="language-js">var fs = require('fs')
var fn = './foo'  // file name
fs.writeFileSync(fn, '1234\n')
fs.createReadStream(fn).pipe(process.stdout)  // → 1234
fs.writeFile(fn, '2345\n')
fs.createReadStream(fn).pipe(process.stdout)  // The file is empty.
</code></pre>
<p>This is the code I submitted as <a href="https://github.com/nodejs/node-v0.x-archive/issues/7807">an issue</a> to Joyent’s node (prior to
the io.js fork).</p>
<p>So what is going on? Why does it break your implicit consistency expectations?
It turns out that the operations you use are not atomic. What <code>fs.writeFile()</code>
really means is “Empty the file immediately, and some day, please fill it with
this.” In POSIX terms, you perform an
<code>open(…, O_WRONLY|O_CREAT|O_TRUNC|O_NONBLOCK)</code>, and the <code>O_TRUNC</code> empties the
file. Since it is <code>O_NONBLOCK</code>, the next line of code gets executed immediately.
Then, Node.js’ event loop spins: on the next tick, it polls, and the file system
tells it that it is done (and indeed, it is). Note that it can take many more
event loop ticks, if there is a larger amount of data written.</p>
<p>Fundamentally, why would you ever want those default flags (aka. <code>fopen</code>’s
<code>'w'</code>)? If you are writing logs or uploading a file to the server, you want
<code>'a'</code> instead; if you are updating configuration files or any type of data, you
want… something that will be described in the next chapter. For any type of file
that has the risk of being read, this default flag is the wrong one to use.</p>
<p>So, the problem is that it was non-blocking, right? After all, if we change it
to be synchronous, it all seems to work, right?</p>
<pre><code class="language-js">var fs = require('fs')
var fn = './foo'  // file name
fs.writeFileSync(fn, '1234\n')
fs.createReadStream(fn).pipe(process.stdout)  // → 1234
fs.writeFileSync(fn, '2345\n')
fs.createReadStream(fn).pipe(process.stdout)  // → 2345
</code></pre>
<p>Don’t you hate it when you read a blog post, and the author ends two
consecutive sentences with “right?”, and you just know it means “false!”</p>
<h2>File Systems</h2>
<p>What if your application crashes?</p>
<p>Having your app crash just after you opened the file for writing, but before it
is done writing, will unsurprisingly result in a half-written file — or an empty
one. Since the memory of the crashed app is reclaimed, the data that was not
written is lost forever!</p>
<p>You want to <em>replace a file</em>. Therefore, even if the application crashes, you
want to make sure that you maintain either the old version, or the new version,
but not an in-between. <code>fs.writeFileSync()</code> does not offer that guarantee, just
as the underlying POSIX primitives. It is tempting, but wrong.</p>
<p>In <a href="http://thunk.org/tytso/blog/2009/03/12/delayed-allocation-and-the-zero-length-file-problem/comment-page-5/#comment-2782">the words</a> of Theodore Ts’o, maintainer of ext4, the most used
file system on Linux and possibly in the world (and creator of <code>/dev/random</code>):</p>
<blockquote>
<p>Unfortunately, there very many application programmers that attempt to update an existing file’s contents by opening it with O_TRUNC. I have argued that those application programs are broken, but the problem is that the application programmers are “aggressively ignorant”, and they outnumber those of us who are file system programmers.</p>
</blockquote>
<p>The fundamental issue is that <code>fs.writeFileSync()</code> is not atomic. It is a series
of operations, the first of which deletes the old version of the file, the next
ones slowly inserting the new version.</p>
<p>What do we want? The new version! When do we want it? Once written on disk,
obviously. We have to first write the new version on disk, alongside the old
one, and then switch them. Fortunately, POSIX offers a primitive that performs
that switch <em>atomically</em>. World, meet <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/rename.html"><code>rename()</code></a>.</p>
<pre><code class="language-js">var tmpId = 0
var tmpName = () =&gt; String(tmpId++)
var replaceFile = (file, data, cb) =&gt; {
  var tmp = tmpName()
  fs.writeFile(tmp, data, err =&gt; {
    if (err != null) { cb(err); return }
    fs.rename(tmp, file, cb)
  })
}
</code></pre>
<p>Obviously, I simplify a few things in this implementation:</p>
<ul>
<li>We have to verify that the <code>tmp</code> file does not exist,</li>
<li>We should make <code>tmp</code> have a UUID to reduce the risk that another process
creates a file with the same name between the moment we check for its
existence and the moment we write to it,</li>
<li>We said before that Node.js was using <code>'w'</code> as the default write flag; we want
to use at least <code>'wx'</code> instead. <code>x</code> is a Node.js invention that uses <code>O_EXCL</code>
instead of <code>O_TRUNC</code>, so that the operation fails if the file already exists
(we would then retry with a different UUID),</li>
<li>We need to create <code>tmp</code> with the same permissions as <code>file</code>, so we also need
to <code>fs.stat()</code> it first.</li>
</ul>
<p>All in all, the finished implementation is nontrival. But this is it, right?
This is the end of our ordeal, right? We finally maintained consistency, right?</p>
<p>I have good news! According to POSIX, yes, this is the best we can do!</p>
<h2>Kernel Panics</h2>
<p>We settled that <em>write temporary then rename</em> survives app crashes under
POSIX. However, there is no guarantee for system crashes! In fact, POSIX gives
absolutely no way to maintain consistency across system crashes with certainty!</p>
<p>Did you really think that being correct according to POSIX was enough?</p>
<p>When Linux used ext2 or ext3, app developers used <em>truncate then write</em> or the
slightly better <em>write temporary then rename</em>, and everything seemed fine,
because system crashes are rare. Then a combination of three things happened:</p>
<ul>
<li>Unlike ext3, ext4 was developed with <strong>delayed allocation</strong>: writes are
performed in RAM, then it waits for a few seconds, and only then does it apply
the changes to disk. It is great for performance when apps write too often.</li>
<li>GPU vendors started writing drivers for Linux. Either they didn’t care much
about their Linux userbase, or all their drivers are faulty: the case remains
that <strong>those drivers crashed a lot</strong>. And yet, the drivers are part of the
kernel: they cause system crashes, not recoverable application crashes.</li>
<li><strong>Desktop Linux</strong> users started playing games.</li>
</ul>
<p>What had to happen, happened: a user played a game that crashed the system, at
which point all files that had been updated in the past 5 seconds were zeroed
out. Upon reboot, the user had lost a lot of data.</p>
<p>There were a lot of sad Linux users and grinding of teeth. As a result, Theodore
Ts’o <a href="http://thunk.org/tytso/blog/2009/03/12/delayed-allocation-and-the-zero-length-file-problem/">patched</a> the kernel to detect when apps update files
the wrong way (ie, both <em>truncate then write</em> and <em>write temporary then
rename</em>), and disabled delayed allocation in those cases.</p>
<p>Yes. <em>Write temporary then rename</em> is also the wrong way to update a file. I
know, it is what I just advised in the previous section! In fact, while POSIX
has no way to guarantee consistency for file updates, here is the closest thing
you’ll get:</p>
<ol>
<li>Read the file’s permissions.</li>
<li>Create a temporary file in the same directory, with the same permissions,
using <code>O_WRONLY</code>, <code>O_CREAT</code> and <code>O_EXCL</code>.</li>
<li>Write to the new file.</li>
<li><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/fsync.html"><code>fsync()</code></a> that file.</li>
<li>Rename the file over the file you want to update.</li>
<li><code>fsync()</code> the file’s directory.</li>
</ol>
<p>Isn’t it <a href="http://thunk.org/tytso/blog/2009/03/15/dont-fear-the-fsync/">obvious</a> in retrospect?</p>
<p><em>Renaming the file before it is <code>fsync</code>’ed</em> creates a window of time where a
crash would make the directory point to the updated file, which isn’t committed
to disk yet (as it was in the file system cache), and so the file is empty or
corrupt.</p>
<p>Less harmful, <em>a crash after renaming and before the directory’s cache is
written to disk</em> would make it point to the location of the old content. It
doesn’t break atomicity, but if you only want to perform some action after the
file was replaced <em>for sure</em>, you would better <code>fsync</code> that directory before you
do something you will regret. It might seem like nothing, but it can break your
assumptions of data consistency.</p>
<p>If you own an acute sense of observation, you noticed that, while Theodore’s
patch makes it less likely that “badly written file updates” will cause files to
be zeroed out upon a system crash, the bug always existed and still exists! The
timespan where things can go horribly wrong is only reduced. The fault is
rejected on the app developers.</p>
<p>This issue was “fixed” — well, the patch landed at least — in Linux 2.6.30 on
the most common file systems (ext4 and btrfs).</p>
<h2>Conclusion</h2>
<p>Here’s one thing to get away from all this: file systems have a design which
works well with certain operations and… not so well… with others. <strong>Replacing a
file is costly!</strong> You should know what you are doing (or use <a href="https://www.npmjs.com/package/fsos">fsos</a>, my npm
library which wraps all of this in sweet promises), and only replace files at
worst a few times a second. Ideally a lot less often, especially for large
files.</p>
<p>Realistically, though, what you fundamentally want is not to lose work that is
older than X seconds, for some value of X that is thankfully often larger than
a half.</p>
<p>Besides, this is Node.js. One issue that is common elsewhere with a trivial
implementation is that the main thread waits for the I/O to be finished before
it can move on. In Node.js, we get asynchrony for free. The file replacement
happens essentially in the background. The main thread stays as responsive as a
happy antelope!</p>
<p>PS: I feel like I should also advocate for a few things. For every mistake,
there is both a lesson and a prevention; we have only just learned the lesson.
Programmers go to the path of least resistance, and what they face encourages
them to the pit of death. I see two splinters to remove:</p>
<ol>
<li>Linux should offer an atomic file replacement operation that does it all
right. Theodore argues that it is glib’s (and other libraries’) task, but I
disagree. To me, one of the most common file operations doesn’t have its
syscall.</li>
<li>Node.js’ defaults ought to be improved. <code>fs.writeFile()</code> heavily suggests
being used for file updates, and has the default flag of <code>'w'</code>. It is a terribly
ill-advised primitive for any use. It should be replaced by <code>'ax'</code>, but it
cannot, because of legacy! I recommend having a warning, and a separate
<code>fs.updateFile()</code> function.</li>
</ol>
<script type="application/ld+json">
{ "@context": "http://schema.org",
  "@type": "BlogPosting",
  "datePublished": "2018-05-31T19:42:00Z",
  "keywords": "storage, posix" }
</script> ]]>
        </content>
      </entry>
      <entry>
        <id>https://espadrine.github.io/blog/posts/thefiletree-design-log-4.html</id>
        <link rel="alternate" type="text/html" href="https://espadrine.github.io/blog/posts/thefiletree-design-log-4.html"/>
        <title>TheFileTree Design Log 4: Accounts</title>
        <published>2018-03-01T23:19:58Z</published>
        <category term="tree"/>
        <content type="html">
          <![CDATA[ <h1>TheFileTree Design Log 4: Accounts</h1>
<p>I mentionned needing to add accounts in <a href="./thefiletree-design-log-2.html">design log 2</a>. It is <a href="https://github.com/garden/tree/commit/04a03786d81733aeca35b1ac4fe5b95c57d0e706">now implemented</a>.</p>
<p>You go to <code>/app/account/</code>, which contains either your account information if you are logged in, or a form to get registered.</p>
<p><img src="https://i.imgur.com/rlfES3K.png" alt="Create an Account" /></p>
<p><img src="https://i.imgur.com/5oZdUdH.png" alt="Congratulations for signing up" /></p>
<p>You get an email with a link back to the website, which gives you a httpOnly secure cookie with a token that the database will recognize and associate to a JSON blob containing your information (email, user name).</p>
<p><img src="https://i.imgur.com/mWxce40.png" alt="Email with link" /></p>
<p><img src="https://i.imgur.com/bNBGooa.png" alt="Welcome page" /></p>
<p><img src="https://i.imgur.com/Pw4thNV.png" alt="Account page" /></p>
<p>As planned, I use email-login, which I improved for this purpose by adding support for <a href="https://www.cockroachlabs.com/">CockroachDB</a>, a serializable distributed SQL database that I plan on using more (maybe for file metadata).</p>
<p>All files <a href="https://github.com/garden/tree/commit/6fbe24c41dfa7085533a6a0157daefc5a28ed7a4">now</a> have an Access Control List (ACL) so that you can set the default access (none (404), reader, writer (can see and edit), owner (can also change the metadata, and therefore the ACL).</p>
<p><img src="https://i.imgur.com/2lROKuf.png" alt="Folder ownership" /></p>
<p>ACLs on folders apply to all subfiles unless an explicit ACL overrides it. It works like variable scoping: the nearest containing metafolder with an explicit ACL that applies to you determines your access.</p>
<p>It works by setting the <code>acl</code> JSON object in the metadata. It is a map from username to right: <code>-</code> for none, <code>r</code> for reader, <code>w</code> for writer, <code>x</code> for owner.  Does it remind you of Unix permissions?</p>
<p><img src="https://i.imgur.com/c04V9J9.png" alt="JSON metadata" /></p>
<p>The <code>*</code> key is for other users (logged in or anonymous).</p>
<h2>Canop Finishing Touches</h2>
<p>Code and bugs are lovers. The monster that I am had to crush a handful of the latter, but it really was to save the former.</p>
<p>For instance, <strong>undo/redo</strong> was semantically wrong.</p>
<p>Why? Of course, CodeMirror supports undo/redo, but it keeps track of all changes. However, when you are editing code with others, you only want to undo <em>your own changes</em>. If you wrote a word and press <em>Undo</em>, you expect your word to be removed, not the operations that someone else did in the meantime.</p>
<p>That required <a href="https://github.com/espadrine/canop/commit/ed07dc80f8da61da15dee0703893315b1f863ba6">managing my own undo stack</a></p>
<p>Another tricky situation arose while testing when I started using <strong>multiple cursors</strong>, a feature that every text editor under the sun stole from <a href="https://www.sublimetext.com/docs/2/multiple_selection_with_the_keyboard.html">SublimeText</a> (although Wikipedia <a href="https://en.wikipedia.org/wiki/Simultaneous_editing">mentions</a> MIT’s <a href="https://en.wikipedia.org/wiki/Simultaneous_editing">LAPIS</a> as the first to sport it, as part of their academic paper.)</p>
<p>I received the editing operations CodeMirror gave me from the <code>change</code> events after it had already updated the editor. The operation positions I dealt with could not easily be mapped back to indices, as they related to the editor’s state before the change.</p>
<p>I tried getting inspiration from <a href="https://github.com/Operational-Transformation/ot.js/blob/8873b7e28e83f9adbf6c3a28ec639c9151a838ae/lib/codemirror-adapter.js#L55">ot.js</a>, but ended up relying on a <a href="https://github.com/espadrine/canop/commit/1bc109bfc6b075b1a59d4e2401f902edfdf8288a">simpler algorithm using the <code>beforeChange</code> event</a>.</p>
<p>It does have the downside that you don’t automatically have multiple changes that are semantically combined (like deleting multiple selections). Those end up having a single undo entry, for instance. I was getting used to reimplementing CodeMirror things, so naturally I implemented a <a href="https://github.com/espadrine/canop/commit/7beec5d1b8e231e0a52c6402931d5db77c2491da">time-based operation grouping system</a>.</p>
<h2>Deploying To Production</h2>
<p>The first version of TheFileTree was located on a server under our college
dormroom desks; the second in a college server; the third on a friend’s
subletting server offer; the fourth on an OVH VPS. This one will be on Google
Cloud, starting with their free tier, where it should fit for some time before
it, hopefully starts generating revenue to be self-sustaining.</p>
<p>It did require some subtle tweaking to support the fact that sending emails is
severely restricted on Google Cloud. There is a handful of partners that you
have to go through; I picked MailJet. I tweaked the <code>email-login</code> npm package
and my DNS zone file to make it work.</p>
<p>As far as administrator interfaces are concerned, Google Cloud is extremely
polished, offering a clean interface with good configuration, and even a
convenient remote SSH-in-a-tab.</p>
<p>While it is still slightly slower to get up and running with a fresh instance
than on Digital Ocean, it is a step up from OVH. That said, OVH offers a
predictable fixed cost and no egress cost, while GCP will have complicated costs
to manage once I need to look after them.</p>
<p>Sadly, to get on the free tier, I was required to host the servers in South
Carolina, US. There is a subtle bit more latency as a result from France.</p>
<p>All in all, it was a very interesting choice to have. The website is now much
more robust than it was before. The only dark spot is the single-node
CockroachDB server, which dies on a regular basis, seemingly because it does not
like to be alone. I will have to investigate further later.</p>
<script type="application/ld+json">
{ "@context": "http://schema.org",
  "@type": "BlogPosting",
  "datePublished": "2018-03-01T23:19:58Z",
  "keywords": "tree" }
</script> ]]>
        </content>
      </entry>
      <entry>
        <id>https://espadrine.github.io/blog/posts/what-i-built-in-2017.html</id>
        <link rel="alternate" type="text/html" href="https://espadrine.github.io/blog/posts/what-i-built-in-2017.html"/>
        <title>What I Made In 2017</title>
        <published>2018-02-23T21:37:12Z</published>
        <category term="retro"/>
        <content type="html">
          <![CDATA[ <h1>What I Made In 2017</h1>
<p>After some time working on the collaboration between <a href="https://trainline.eu">Captain Train</a> and its
acquirer <a href="https://www.thetrainline.com">Trainline</a>, to bring together both companies’ technologies through a
common protocol, and maintaining the SNCF integration through major evolutions
of their offerings, I left the company to join <a href="https://qonto.eu">Qonto</a></p>
<p>This bank startup that just came out of beta when I joined (I literally removed
the beta tag from the website on my first week) offers the most streamlined
online banking experience for businesses.</p>
<p>I brought together a great team. This year, we will focus on making the backend
banking integration top-notch.</p>
<p>As a result, I had less time for free-time open-source. There were three big
directions to what I did:</p>
<ul>
<li>The <a href="https://shields.io">Shields.io</a> core team increased, and it allowed us to optimize things
like the <a href="https://github.com/badges/shields/pull/1390">font-width computation</a> (hat tip to Paul Melnikow for that).</li>
<li>I pursue <a href="https://thefiletree.com">TheFileTree</a>, to provide the infrastructure for a self-helping
community of makers. (It is very far from there yet.) I switched it to using
the <a href="https://github.com/espadrine/canop">Canop</a> system, which I still have to make support a full JSON, to allow
for more complex apps. I redid the API and made the app system as designed
the year before.</li>
<li>I played with AI in the stride of DeepMind’s [AlphaGo][] effort, and produced
a Node.js Go library, <a href="https://github.com/espadrine/badukjs">badukjs</a>.</li>
</ul>
<p>To sum up, this year, I switched focus from “me” to “us”. Great things are not a
lonely job, but an active coordination.</p>
<p>Next year, I will focus on building-block infrastructure for more cooperation.</p>
<p><a href="http://espadrine.github.io/blog/posts/what-i-made-in-2016.html">Previously</a>.</p>
<script type="application/ld+json">
{ "@context": "http://schema.org",
  "@type": "BlogPosting",
  "datePublished": "2018-02-23T21:37:12Z",
  "keywords": "retro" }
</script> ]]>
        </content>
      </entry>
</feed>
