{
  "version": "https://jsonfeed.org/version/1",
  "title": "Espadrine’s blog",
  "description": "Let’s talk about whatever I learn!",
  "home_page_url": "https://espadrine.github.io/blog/",
  "feed_url": "https://espadrine.github.io/blog/feed.json",
  "author": {
    "name": "Thaddée Tyl",
    "url": "https://github.com/espadrine"
  },
  "favicon": "https://avatars.githubusercontent.com/u/100689?s=64",
  "items": [
      {
        "id":  "https://espadrine.github.io/blog/posts/a-base32-checksum.html",
        "url": "https://espadrine.github.io/blog/posts/a-base32-checksum.html",
        "title": "A base32 checksum",
        "tags": "hash",
        "date_published": "2019-04-29T14:18:51Z"
        "content_html": "<h1>A base32 checksum</h1>\n<p><em>(Cue: in the voice of a badly-acted TV commercial.)</em></p>\n<blockquote>\n<p>Do you always mistakenly wire money to or from the wrong account?\nI used to do that all day, everyday!</p>\n<p>But then, I found base32check, and my life turned upside-down.\nbase32check is there for me on my daily purchases, watching out for my\nerroneous transcriptions online and offline! And now, for some reason,\nI smell of roses and there are sparkling AfterEffects™ all around.</p>\n<p>Download the base32check whitepaper. Symptoms may include an accelerated heart\nrate, a shortness of breath, and acute depression. Please consult your\nhealthcare professional in case of severe brain injury.</p>\n</blockquote>\n<h2>That was weird, let’s be boring instead</h2>\n<p>When credit cards sprung into our lives, they were designed to prevent that.\nThe last digit served no other purpose than to act as a checksum, computed\nfrom the other digits, using an algorithm by Hanz <strong><a href=\"https://patents.google.com/patent/US2950048\">Luhn</a></strong> from 1959.\nIn his words:</p>\n<blockquote>\n<p>It is commonly known that in copying a number comprised of a plurality of\ndigits it often happens that an error occurs by transposing two of the\ndigits.</p>\n</blockquote>\n<p>Luhn’s goal was to detect all single-digit errors and most transpositions,\nwith a single check digit. However, it missed some transpositions, such as\n09 / 90.</p>\n<div id=luhnWidget>\n  <input class=luhnInput value=1234590>\n  <strong><output class=luhnValidity>Valid</output></strong>\n  (Add a <strong><output class=luhnDigit>6</output></strong> to be valid).\n</div>\n<script>\n// From https://github.com/EDumdum/luhn/blob/master/src/luhn.js\nfunction luhnValid(value) {\n  return /^[0-9]+$/.test(value) && luhnRemainder(value) === 0;\n}\nfunction luhnGen(value) {\n  if (!/^[0-9]+$/.test(value)) { value = ''; }\n  return ((10 - luhnRemainder(value + '0')) % 10);\n}\nfunction luhnRemainder(value) {\n  var array = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9];\n  var length = value.length, accumulator = 0, bit = 0;\n  while (length-- > 0) {\n    accumulator += (bit ^= 1) ? value.charCodeAt(length) - '0'.charCodeAt(0) : array[value.charCodeAt(length) - '0'.charCodeAt(0)];\n  }\n  return accumulator % 10;\n}\nfunction initLuhnWidget() {\n  const luhnWidget = document.getElementById('luhnWidget');\n  const luhnInput = luhnWidget.getElementsByClassName('luhnInput')[0];\n  const luhnValidity = luhnWidget.getElementsByClassName('luhnValidity')[0];\n  const luhnDigit = luhnWidget.getElementsByClassName('luhnDigit')[0];\n  const updateWidget = () => {\n    const value = luhnInput.value;\n    luhnValidity.textContent = luhnValid(value) ?  'Valid' : 'Invalid';\n    const digit = luhnGen(value);\n    luhnDigit.textContent = (digit !== digit) ? 'removal of non-digits' : digit;\n  };\n  luhnInput.addEventListener('input', updateWidget);\n  updateWidget();\n}\naddEventListener('DOMContentLoaded', initLuhnWidget);\n</script>\n<p>Whether a single check digit could also detect all adjacent transpositions\nwas an open question, until 1969, when <strong><a href=\"https://onlinelibrary.wiley.com/doi/abs/10.1002/zamm.19710510323\">Verhoeff</a></strong> designed another\nalgorithm that did just that.\nFurthermore, he gathered the results of a study into a thorough analysis\nof the causes of human errors.</p>\n<p>Meanwhile, the International Standards Organization published\n<a href=\"https://www.iso.org/standard/31531.html\">ISO/IEC 7064</a> in 1983. It includes algorithms for single- and\ndouble-digit checksums of numerical and alphanumerical inputs, with the goal\nto detect all single substitutions and most adjacent transpositions.</p>\n<p>They intended it for use in future standards.\nFor instance, <strong><a href=\"https://www.iso.org/standard/41031.html\">IBAN</a></strong> (the International Bank Account Number)\nneeded a checksum to lower the risk of accidentally transfering funds to the\nwrong account number.</p>\n<p>Surprisingly, the IBAN system, which supports alphanumeric characters,\nrelied on MOD 97-10, which was designed only for numeric inputs.</p>\n<p>Our analysis indicates that this was a BAD MOVE™.</p>\n<p>A root promise of MOD 97-10 as specified in <a href=\"https://www.iso.org/standard/31531.html\">ISO/IEC 7064</a> is to detect\nall single substitution errors. Well, not anymore! Not with that\nalphabetic-to-numeric conversion. For instance, <code>IIIIIII80</code> conflicts with\n<code>IIIII1I80</code>, <code>UDODGOP17</code> with <code>UDODG0P17</code>.</p>\n<div id=mod97_10Widget>\n  <input class=mod97_10Input value=AB123>\n  <strong><output class=mod97_10Validity>Valid</output></strong>\n  (Add a <strong><output class=mod97_10Digit>92</output></strong> to be valid).\n  <p><button class=findCollision>Find collision</button>\n  <output class=collision></output>\n</div>\n<script>\n// From https://github.com/arhs/iban.js/blob/master/iban.js\nfunction iso7064Mod97_10(value) {\n  var remainder = value, block;\n  while (remainder.length > 2){\n    block = remainder.slice(0, 9);\n    remainder = parseInt(block, 10) % 97 + remainder.slice(block.length);\n  }\n  return parseInt(remainder, 10) % 97;\n}\n\nfunction iso13616Prepare(value) {\n  if (!/^[0-9a-zA-Z]+$/.test(value)) { value = ''; }\n  const A = 'A'.charCodeAt(0), Z = 'Z'.charCodeAt(0);\n  value = value.toUpperCase();\n  return value.split('').map(function(n){\n    var code = n.charCodeAt(0);\n    if (code >= A && code <= Z){\n      // A = 10, B = 11, ... Z = 35\n      return code - A + 10;\n    } else { return n; }\n  }).join('');\n}\n\nfunction mod97_10Valid(value) {\n  return /^[0-9a-zA-Z]+$/.test(value) &&\n    iso7064Mod97_10(iso13616Prepare(value.slice(0, -2))).toString() === value.slice(-2);\n}\n\nfunction mod97_10FindCollision(value) {\n  if (!mod97_10Valid(value)) { return; }\n  const target = value.slice(-2);\n  const input = value.slice(0, -2);\n  const alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  for (let i = 0; i < input.length; i++) {\n    for (let a = 0; a < alphabet.length; a++) {\n      const other = input.slice(0, i) + alphabet[a] + input.slice(i + 1);\n      if (other === input) { continue; }\n      if (iso7064Mod97_10(iso13616Prepare(other)).toString() === target) {\n        return other + target;\n      }\n    }\n  }\n}\n\nfunction initMod97_10Widget() {\n  const widget = document.getElementById('mod97_10Widget');\n  const mod97_10Input = widget.getElementsByClassName('mod97_10Input')[0];\n  const mod97_10Validity = widget.getElementsByClassName('mod97_10Validity')[0];\n  const mod97_10Digit = widget.getElementsByClassName('mod97_10Digit')[0];\n  const updateWidget = () => {\n    const input = iso13616Prepare(mod97_10Input.value);\n    mod97_10Validity.textContent = mod97_10Valid(input) ?  'Valid' : 'Invalid';\n    const digits = iso7064Mod97_10(input);\n    mod97_10Digit.textContent = (digits !== digits) ? 'removal of non-alnums' :\n      digits.toString().padStart(2, '0');\n  };\n  mod97_10Input.addEventListener('input', updateWidget);\n  updateWidget();\n\n  const findCollisionBut = widget.getElementsByClassName('findCollision')[0];\n  const collisionOutput = widget.getElementsByClassName('collision')[0];\n  findCollisionBut.addEventListener('click', event => {\n    const other = mod97_10FindCollision(mod97_10Input.value);\n    if (other === undefined) {\n      collisionOutput.value =\n        'No conflicting single substitution found, try adding valid digits.';\n    } else { collisionOutput.value = other; }\n  });\n}\naddEventListener('DOMContentLoaded', initMod97_10Widget);\n</script>\n<p>Furthermore, while it technically allows mixed case, the uppercase letter always\nconflicts with its lowercase, essentially making lowercase too risky to\nuse. Uppercase all inputs.</p>\n<p>On the other hand, MOD 97-10 checksums do not produce letters, which leaves\nsome of the information content of the checksum on the table, that could\notherwise strengthen the checksum.</p>\n<h2>A Blank Slate</h2>\n<p>If we were to redesign the global banking system, how would we improve this?</p>\n<p>The goals we want for our imaginary account number are:</p>\n<ol>\n<li><strong>Be easy to transmit.</strong> So, text.</li>\n<li><strong>Be short</strong>, to simplify copying.</li>\n<li><strong>Contain enough space to scale globally</strong>. We don’t want to run out of\naccount numbers as the population grows. This, along with the previous\nconstraint, means that we need to encode as many bits of information as\nwe can within each character. base64 maybe? That’d be 6 bits per char.</li>\n<li><strong>Minimize human transcription errors</strong>. base64 is notably poor in this\nrespect, because of the 0/O and I/l/1/i visual confusion. On the other\nhand, base32 has more information density than just digits, but none of\nthe ambiguity. Finally, while base64 contains a dash or a dot that can\nbe cut off by text processors, base32 will be selected as a single word\neven when double-clicking.</li>\n<li><strong>Allow early detection of errors</strong>. We don’t want to inform the user\nof their mistake asynchronously. So the algorithm should be easy to\nimplement on the user-interface.</li>\n</ol>\n<p>Obviously, I am not the first to look into this. Notably, <a href=\"https://en.bitcoin.it/wiki/Base58Check_encoding#Background\">Bitcoin</a>\ncreated a solution for this. How does it work, and how does it fare?</p>\n<p>In Bitcoin, the account number is roughly a (cryptographic) hash of the user’s\npublic key, cut and concatenated with a checksum that also uses a cryptographic\nhash.</p>\n<p>The account number is usually represented in text as <a href=\"https://en.bitcoin.it/wiki/Base58Check_encoding#Background\">base58</a>. It is very\nsimilar to <a href=\"https://tools.ietf.org/html/rfc4648\">base64</a>, except that it removes the 0/O and l/I ambiguity, but\nstill has the i/1, Z/7, B/8 and S/5 confusion. Besides, transcribing or\ncommunicating mixed-case letters is tedious. Each letter needs mentioning\nwhether it is uppercase or lowercase. That is why <a href=\"https://www.youtube.com/watch?v=bLE7zsJk4AI\">fourwordsalluppercase</a> is a\ngreat WiFi password.</p>\n<p>The checksum uses roughly 5 characters (four bytes of <a href=\"https://en.bitcoin.it/wiki/Base58Check_encoding#Background\">base58</a> is 32 ÷\nlog2(58)). It is fairly big, which at least ensures that there won’t be\nmistakes… unless the account number goes unchecked. If that is the case, neither\nthe sender nor the recipient may use the funds transferred.</p>\n<p>Sadly, the necessity of a bignum library for base58 decoding, and SHA256 as the\nchecksum algorithm, makes verifying the checksum laborious to implement.\nFew user interfaces embed a validator as a result.</p>\n<p>Finally, even if we wanted to replace the checksum with an easier-to-use check\ndigit, it is not immediately easy to design a base58 check character.</p>\n<p><a href=\"https://tools.ietf.org/html/rfc4648\">base32</a> avoids many of these inconveniences, especially in lowercase, where\nthe varied heights are easy to distinguish and where there is no S/5 and Z/7\nambiguity.\nHowever, there isn’t a particularly good, dedicated, check character algorithm\nfor it — yet.</p>\n<p>Let’s create one.</p>\n<h2>base32check1</h2>\n<p>Luhn, Verhoeff, Damm — some pretty nifty designs are already on the shelves.\nSadly, they mostly focus on digits, which have poor information capacity (3.3\nbits per char).</p>\n<p>While they can be extended to larger alphabets, that is not trivial nor\nstandard. (Ah, the joy of tweaking the Verhoeff parameters.) Worse, they are no\nlonger the coolest kids on the block.</p>\n<p>I found a 2016 <a href=\"https://www.uni-due.de/imperia/md/content/dc/yanling_2015_check_digit.pdf\">paper</a> referencing a 2014 one (which I couldn’t get\nmy hands on. Curse the IEEE overseers and their labyrinthic subscription\nmodels! <em>Please pay $84.50 membership and the paper is $14.95, oh and would you\nmind donating because IEEE helps improve the human condition? Also good news, we\noffer free shipping for PDF documents.</em>)</p>\n<p>No joke, but I digress. The 2014 paper has no value anyway, as the principle is\ndescribed in full in the <a href=\"https://www.uni-due.de/imperia/md/content/dc/yanling_2015_check_digit.pdf\">2016 paper</a>, available online.</p>\n<p>The main insight is this: if your check digit a<sub>n+1</sub> solves Σ aᵢ·Pⁱ = 0\non a finite field where P is the companion matrix of a primitive polynomial,\n<em>it suddenly detects substitutions, transpositions, and twin substitutions</em> with\nup to R characters between them, where R grows with the cardinal. Magic!</p>\n<p>(We will dig more into exactly what errors it detects later.)</p>\n<p>You must pick two numbers carefully to design your checksum: the cardinal and\nthe primitive.</p>\n<ul>\n<li>The <strong>cardinal</strong> is the number of elements in the finite field. It is\ntherefore also the number of possible checksums. For a single-character check\ndigit, it must be smaller than the size of your alphabet.</li>\n<li>The <strong>primitive</strong> does not matter all that much. The most significant part\nabout it is that you need to compute one. Unfortunately, brute-force is usually\nthe simplest way to find some.</li>\n</ul>\n<p>There are two possible cardinals: <em>prime numbers</em> and <em>prime powers</em>. Prime\ncardinals are neat, because operations are scalar. On the other hand, additions\nand multiplications on prime power cardinal fields are matricial.</p>\n<p>I first wanted a single-character checksum. In order to use all the bits that\nthis checksum had at its disposal, I needed it to support the full base32\nalphabet. That meant the cardinal needed to be 32. Sadly, 32 is not a prime; so\nit needed to be a prime power. If 2 is the prime, 2⁵ is the cardinal.</p>\n<p>Since the cardinal is not a prime, P is a matrix. Here, its size is 5×5.\nTo build it, we can pick any order-5 <a href=\"http://mathworld.wolfram.com/PrimitivePolynomial.html\">primitive polynomial</a>; I chose 1+x²+x⁵.\nTo get the companion matrix, set a diagonal of 1s, and set the rightmost column\nwith the polynomial coefficients, starting with x⁰:</p>\n<pre><code>⎛ 0 0 0 0 1 ⎞\n⎜ 1 0 0 0 0 ⎟\n⎜ 0 1 0 0 1 ⎟\n⎜ 0 0 1 0 0 ⎟\n⎝ 0 0 0 1 0 ⎠\n</code></pre>\n<p>Each aᵢ term is a representation of a base32 character as a GF(2⁵) (finite field\nof order 2⁵) polynome: a is 0, which we represent as (0 0 0 0 0); b is 1 or (0 0\n0 0 1); f is 1+x² or (0 0 1 0 1).</p>\n<p>Validating a check character is straightforward: compute Σ aᵢ·Pⁱ; verify that\nthe result is a zero vector. It does involve writing custom matrix\nmultiplication and addition primitives to ensure that they are all computed\nmodulo the cardinal.</p>\n<p>Unsurprisingly, the performance is not all that great:</p>\n<pre><code>$ node test/perf\n10000 runs.\nbase32check1: 243.500ms\n</code></pre>\n<p>There is a <a href=\"https://johnkerl.org/doc/ffcomp.pdf\">neat trick</a> to speed up computation on a finite field where\nthe cardinal is a power of 2: instead of implementing vectors as arrays, use\nintegers whose binary sequence is the list of polynome coefficients. For\ninstance, 1+x² (which represents f) is <code>0b00101</code>, or 5.</p>\n<p>Then <strong>addition is XOR</strong>, and matrix multiplication is a conditional XOR on the\nsuccessive bits of the current row. With aᵢ and bᵢ vectors of size 5:</p>\n<pre><code>⎛ a₀ ⎞   ⎛ b₀ ⎞   ⎛ Σ a₀[i]×bᵢ ⎞\n⎜ a₁ ⎟   ⎜ b₁ ⎟   ⎜ Σ a₁[i]×bᵢ ⎟\n⎜ a₂ ⎟ × ⎜ b₂ ⎟ = ⎜ Σ a₂[i]×bᵢ ⎟\n⎜ a₃ ⎟   ⎜ b₃ ⎟   ⎜ Σ a₃[i]×bᵢ ⎟\n⎝ a₄ ⎠   ⎝ b₄ ⎠   ⎝ Σ a₄[i]×bᵢ ⎠\n</code></pre>\n<p>It is 7× faster.</p>\n<pre><code>$ node test/perf\n10000 runs.\nbase32check1: 34.120ms\n</code></pre>\n<p>Now, how do you compute the check character?</p>\n<p>First, compute S = Σ aᵢ·Pⁱ for the data you have.\nThen, we need to solve S + c·P<sup>n+1</sup> = 0 for c.</p>\n<p>Let’s compute c·P<sup>n+1</sup> = -S.\nOpposites are equal in GF(2ᵏ), so -S = S.</p>\n<p>The second insight is that, since a primitive element is a generator of\nits finite field, its powers loop around through all non-zero values. Therefore,\nP<sup>2ᵏ-1</sup> = 1, and so, P<sup>n+1</sup>·P<sup>2ᵏ-n-2</sup> = 1.\nThis gives us the inverse of P<sup>n+1</sup>, which we can get by generating\nall the powers of P when initializaing the system.</p>\n<p>Then we have c = S·P<sup>2ᵏ-n-2</sup>.</p>\n<div id=base32check1Widget>\n  <input class=input value=consecration>\n  <strong><output class=validity>Valid</output></strong>\n  (Add <strong><output class=checksum>A</output></strong> to be valid).\n</div>\n<script>\n(function() {\n// From https://github.com/espadrine/base32check/blob/master/1.js\nconst cardinal = 32;  // 2^5\nconst primitive = [  // From the 1+x²+x⁵ primitive polynomial.\n  0b00001,\n  0b10000,\n  0b01001,\n  0b00100,\n  0b00010,\n];\n\nfunction matMul(a, b) {\n  const width = 5;\n  const height = a.length;\n  const mat = new Array(height);\n  for (let i = 0; i < height; i++) {\n    mat[i] = 0;\n    for (let j = 0; j < width; j++) {\n      if ((a[i] & (1 << (width - j - 1))) !== 0) {\n        mat[i] ^= b[j];\n      }\n    }\n  }\n  return mat;\n}\n\nfunction matCp(a) {\n  let copy = new Array(a.length);\n  for (let i = 0; i < a.length; i++) {\n    copy[i] = a[i];\n  }\n  return copy;\n}\n\nconst primitivePowers = (function genPowersOfPrimitive() {\n  // Index 0 contains P^0 = I, 1 has P^1, … 30 has P^30.\n  const powers = [ [], matCp(primitive) ];\n  let p = powers[1];\n  for (let i = 0; i < cardinal - 3; i++) {\n    p = matMul(p, primitive);\n    powers.push(p);\n  }\n  powers[0] = matMul(p, primitive);\n  return powers;\n})();\n\nfunction fromBase32Char(c) {\n  return c.charCodeAt(0) - (/[a-z]/.test(c)? 97: 24);\n}\n\nfunction toBase32Char(c) {\n  c = +c;\n  const d = (c > 25)? (c + 24): (c + 97);\n  return String.fromCharCode(d);\n}\n\nfunction compute(payload) {\n  payload = String(payload).toLowerCase();\n  const n = payload.length;\n\n  // We must solve Σ ai P^i = 0 for i from 1 to n+1.\n  // First, compute Σ ai P^i for i from 1 to n.\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    const a = fromBase32Char(payload[i]);\n    sum ^= matMul([a], primitivePowers[(i+1) % (cardinal-1)])[0];\n    //console.log(`a ${a}\\texp ${i+1}\\tsum ${sum}`);\n  }\n\n  // We must solve:  sum + code * primitive^(n+1) = 0\n  // That is:        sum + opposite           = 0\n  // Therefore:      opposite = -sum\n  // In GF(2), matrices are their own opposites.\n  const opposite = sum;\n\n  // We must solve:  code * primitive^(n+1) = opposite\n  // We know:        a^(cardinal-1) = 1\n  // Therefore:      a * a^(cardinal-2) = 1\n  // Here we have:   a = primitive^(n+1)\n  // Hence:          code = opposite * primitive^((cardinal-2)*(n+1))\n  let exp = (cardinal-n-2) % (cardinal - 1);\n  exp = (exp < 0)? exp + cardinal: exp;\n  const inverse = primitivePowers[exp];\n  const code = matMul([opposite], inverse)[0];\n  //console.log(`opposite ${opposite}\\texp ${exp}\\tinverse ${JSON.stringify(inverse)}\\tcode ${code}`);\n  return toBase32Char(code);\n}\n\nfunction validate(payload) {\n  return compute(payload) === 'a';\n}\n\nfunction init() {\n  const widget = document.getElementById('base32check1Widget');\n  const input = widget.getElementsByClassName('input')[0];\n  const validity = widget.getElementsByClassName('validity')[0];\n  const checksum = widget.getElementsByClassName('checksum')[0];\n  const updateWidget = () => {\n    const value = input.value;\n    validity.textContent = validate(value) ?  'Valid' : 'Invalid';\n    const check = compute(value);\n    checksum.textContent = (check !== check) ? 'removal of non-base32' : check;\n  };\n  input.addEventListener('input', updateWidget);\n  updateWidget();\n}\naddEventListener('DOMContentLoaded', init);\n})();\n</script>\n<h2>base32check2</h2>\n<p>I chose to also design a 2-character checksum alongside, on the off-chance that\nthe first was not strong enough. There are 2<sup>2×5</sup> = 1024 possible\ncombinations of two characters of base32. Using the same design as above, it\nrequired working on 10×10 matrices. I chose not to do that for the following\nreasons:</p>\n<ul>\n<li>The initialization matrix starts to look scary like the Verhoeff one!</li>\n<li>There was opportunity for a design without matrices by instead picking a prime\ncardinal, which would enormously reduce implementation complexity.</li>\n<li>Using a prime instead of a prime power improves your multi-substitution\ndetection. It doesn’t matter for the 1-character checksum, because improving\nyour 2-substitution score at the expense of your single-substitution score is\na net loss.</li>\n</ul>\n<p>So, I picked the largest prime below 1024, 1021, to limit the number of\nsequences of two characters with the same value in GF(p). It does mean that\nreplacing any 75 by aa on even positions will give the same checksum, and the\nsame is true of 76 / ab and 77 / ac.</p>\n<p>I brute-forced a primitive element, and again I took the largest, 1011, although\nthis time, there is no justification, just sheer superstition. (I tried\ncomputing the statistics of detection of all primitives, and they seemed\nequivalent.)</p>\n<p>The computation of the check characters is identical. Since the matrices are now\n1×1, all operations are scalar. Counter-intuitively, it is faster, although\nstill in the same ballpark as our optimized base32check1 design above:</p>\n<pre><code>$ node test/perf\n10000 runs.\nbase32check2: 23.701ms\n</code></pre>\n<div id=base32check2Widget>\n  <input class=input value=apotheosis>\n  <strong><output class=validity>Valid</output></strong>\n  (Add <strong><output class=checksum>AA</output></strong> to be valid).\n</div>\n<script>\n(function() {\n// From https://github.com/espadrine/base32check/blob/master/2.js\nconst cardinal = 1021;\n// Primitive taken from bin/finite-field-primitive-elements 1021.\nconst primitive = 1011;\nconst primitivePowers = (function genPowersOfPrimitive() {\n  const powers = [1, primitive];\n  let p = primitive;\n  for (let i = 0; i < cardinal - 3; i++) {\n    p = (p * primitive) % cardinal;\n    powers.push(p);\n  }\n  return powers;\n})();\n\nfunction fromBase32Char(c) {\n  return c.charCodeAt(0) - (/[a-z]/.test(c)? 97: 24);\n}\n\nfunction toBase32Char(c) {\n  c = +c;\n  const d = (c > 25)? (c + 24): (c + 97);\n  return String.fromCharCode(d);\n}\n\nfunction compute(payload) {\n  payload = String(payload).toLowerCase();\n  if (payload.length % 2 === 1) { payload = 'a' + payload; }\n  const n = payload.length / 2;\n\n  // We must solve Σ ai P^i = 0 for i from 1 to n+1.\n  // First, compute Σ ai P^i for i from 1 to n.\n  let sum = 0;\n  let p = 1;\n  for (let i = 0; i < n; i++) {\n    const a = fromBase32Char(payload[2*i]) * 32 + fromBase32Char(payload[2*i+1]);\n    // We could use primitivePowers here, although this may be faster.\n    p = (p * primitive) % cardinal;\n    sum = (sum + a * p) % cardinal;\n    //console.log(`a ${a}\\tp ${p}\\tsum ${sum}`);\n  }\n\n  // We must solve:  sum + code * primitive^(n+1) = 0\n  // That is:        sum + opposite           = 0\n  // Therefore:      opposite = -sum\n  const opposite = (sum === 0)? 0: (cardinal - sum);\n\n  // We must solve:  code * primitive^(n+1) = opposite\n  // We know:        a^(cardinal-1) = 1\n  // Therefore:      a * a^(cardinal-2) = 1\n  // Here we have:   a = primitive^(n+1)\n  // Hence:          code = opposite * primitive^((cardinal-2)*(n+1))\n  let exp = (cardinal-n-2) % (cardinal - 1);\n  exp = (exp < 0)? exp + cardinal: exp;\n  const inverse = primitivePowers[exp];\n  const code = (opposite * inverse) % cardinal;\n  //console.log(`opposite ${opposite}\\tinverse ${inverse}\\tp ${p}\\tcode ${code}`);\n  return toBase32Char(Math.floor(code / 32)) + toBase32Char(code % 32);\n}\n\nfunction validate(payload) {\n  return compute(payload) === 'aa';\n}\n\nfunction init() {\n  const widget = document.getElementById('base32check2Widget');\n  const input = widget.getElementsByClassName('input')[0];\n  const validity = widget.getElementsByClassName('validity')[0];\n  const checksum = widget.getElementsByClassName('checksum')[0];\n  const updateWidget = () => {\n    const value = input.value;\n    validity.textContent = validate(value) ?  'Valid' : 'Invalid';\n    const check = compute(value);\n    checksum.textContent = (check !== check) ? 'removal of non-base32' : check;\n  };\n  input.addEventListener('input', updateWidget);\n  updateWidget();\n}\naddEventListener('DOMContentLoaded', init);\n})();\n</script>\n<p>The last question we may have is: how well does it compare?</p>\n<h2>Results</h2>\n<style>\nth, td { text-align: \".\" center; }\n</style>\n<table>\n  <tr><th> Error type   <th> Frequency <th> MOD 11-10 <th> MOD 97-10 <th> MOD 37-36 <th> MOD 1271-36 <th> base32check1 <th> base32check2\n  <tr><td> 1sub         <td> 79.05%    <td> 7.6%      <td> 0.291%    <td> 0%        <td> 0%          <td> 0%           <td> 0%\n  <tr><td> 0-trans      <td> 10.21%    <td> 9.503%    <td> 0.405%    <td> 0.195%    <td> 0%          <td> 0%           <td> 0%\n  <tr><td> 0-2sub       <td> 1.92%     <td> 10.167%   <td> 1.084%    <td> 2.892%    <td> 0%          <td> 3.175%       <td> 0.025%\n  <tr><td> 5sub         <td> 1.81%     <td> 10.083%   <td> 0.996%    <td> 2.769%    <td> 0.086%      <td> 3.101%       <td> 0.101%\n  <tr><td> 3sub         <td> 1.4%      <td> 9.975%%   <td> 1.048%    <td> 2.714%    <td> 0.072%      <td> 3.087%       <td> 0.088%\n  <tr><td> 6sub         <td> 1.34%     <td> 9.958%    <td> 1.013%    <td> 2.775%    <td> 0.074%      <td> 3.099%       <td> 0.099%\n  <tr><td> 4sub         <td> 0.97%     <td> 10.042%   <td> 1.033%    <td> 2.737%    <td> 0.069%      <td> 3.133%       <td> 0.1%\n  <tr><td> 1-trans      <td> 0.82%     <td> 11.689%   <td> 0.298%    <td> 1.931%    <td> 0%          <td> 0%           <td> 0%\n  <tr><td> 2sub         <td> 0.81%     <td> 9.909%    <td> 0.971%    <td> 2.689%    <td> 0.05%       <td> 3.022%       <td> 0.055%\n  <tr><td> 0-twin       <td> 0.55%     <td> 9.858%    <td> 0.351%    <td> 1.805%    <td> 0%          <td> 0%           <td> 0%\n  <tr><td> phonetic     <td> 0.49%     <td> 11.199%   <td> 0%        <td> 11.055%   <td> 0%          <td> 0%           <td> 0%\n  <tr><td> 1-2sub       <td> 0.36%     <td> 9.982%    <td> 1%        <td> 2.765%    <td> 0.04%       <td> 3.229%       <td> 0.208%\n  <tr><td> 1-twin       <td> 0.29%     <td> 12.871%   <td> 0.331%    <td> 3.755%    <td> 0%          <td> 0%           <td> 0%\n  <tr><th> Format       <td> N/A       <td> 1-digit   <td> 2-digit   <td> 1-alnum   <td> 2-alnum     <td> 1-base32     <td> 2-base32\n  <tr><th>Detection rate<td> N/A       <td> 91.994%   <td> 99.629%   <td> 99.654%   <td> 99.995%     <td> 99.732%      <td> 99.993%\n  <tr><th> Det. factor  <td> N/A       <td> 0.729     <td> 0.807     <td> 1.581     <td> 1.382       <td> 1.709        <td> 1.380\n</table>\n<p>Error types:</p>\n<ul>\n<li><strong><code>n</code>sub</strong>: a sequence of <code>n</code> single-character substitutions, eg. <code>a..b</code> /\n<code>c..d</code> is a 2sub.</li>\n<li><strong><code>m</code>-trans</strong>: a single transposition between characters that have <code>m</code> other\ncharacters distancing them, eg. <code>a.c</code> / <code>c.a</code> is a 1-trans.</li>\n<li><strong><code>m</code>-<code>n</code>sub</strong>: a sequence of <code>n</code> single-character substitutions that have <code>m</code>\nother characters distancing them, eg. <code>a.b</code> / <code>c.d</code> is a 1-2sub.</li>\n<li><strong><code>m</code>-twin</strong>: two identical characters that are substituted to the same\ncharacter, with <code>m</code> other characters distancing them, eg. <code>a.a</code> / <code>b.b</code> is\na 1-twin.</li>\n<li><strong>phonetic</strong>: <code>1a</code> / <code>a0</code> with a between 1 and 9, eg. thirteen / thirty.</li>\n</ul>\n<p>The frequency column indicates how often a human makes a particular type of\nerror, based on <a href=\"https://onlinelibrary.wiley.com/doi/abs/10.1002/zamm.19710510323\">Verhoeff</a>’s findings.</p>\n<p>We use it to compute an approximate <strong>detection rate</strong>, relying on the\nstatistical proportion of random inputs for which the checksum does not\ndetect a given error type. You can see the proportion of undetected errors\nfor each checksum in the table above.</p>\n<p>We added an interesting figure, the <strong>detection factor</strong>. After all,\nwe want our checksum to make the most of the space it takes. Each bit should\ncontribute to improving the detection rate. Since we expect a law of diminishing\nreturns for every additional bit, the detection rate of a given design should\nimprove with the number of checksum bits by 1 - 2<sup>-k·b</sup>, with b the\nnumber of checksum bits, and k the detection factor, which we compute as\n-log2(1-detection) ÷ b.</p>\n<p>Each check digit is a base32 character, so they each cost 5 bits of\ninformation, except for the alphanumerical ones, which cheat by producing\nvalues that cannot be mapped to base32 characters without increasing the\nerror rate. Those take log2(36) ≈ 5.17 bits.</p>\n<p><em>(The detection factor is not a perfect model, as the <a href=\"https://www.iso.org/standard/31531.html\">ISO/IEC 7064</a>\nalgorithms don’t all have the same factor, despite being the same design with\ntweaked parameters. That said, MOD 1007-32 is between base32check2 and MOD\n1271-36.)</em></p>\n<p>You will notice two positive things:</p>\n<ul>\n<li>Both base32check algorithms have a <em>similar or superior detection rate</em> than\nall others for a given number of check characters. (MOD 1271-36 is essentially\nidentical, apart from the 0/O, 1/I and 8/B confusion risk, which is\nunfortunately not computed here, for lack of empirical data.)</li>\n<li>base32check1 has the <em>best overall detection factor</em>. base32check2 has a\ncomparable one to MOD 1271-36. It is slightly lower, implying that it could\npotentially use its bits better. Indeed, there are a few tweaks that could\nhelp, although I would prefer to await more statistical human error data\nbefore changing the design, as the detection rate varies significantly if\nwe label the 3sub thru 6sub as insertion and deletion errors instead, which\nthey probably are; Verhoeff’s study does not distinguish them.</li>\n</ul>\n<p>While writing the algorithm, I worried that perhaps I would not be able to\nbeat the detection rate of IBAN with a single check character (half the\namount!). The whole point of designing base32check2 was on the off-chance\nthat it didn’t. Fortunately, even base32check1 is better than IBAN’s MOD\n97-10, mostly thanks to IBAN’s character conversion procedure.</p>\n<h2>User Study</h2>\n<p>The computed scores depend on second-hand information from Verhoeff’s study. It\nmay not map accurately to other alphabets, or alphabet sizes.</p>\n<p>Moreover, it does not help determine which alphabet is least error-prone for\nhuman transcription.</p>\n<p>Down to the core, we want to minimize the number of times you send money to the\nwrong account.</p>\n<pre><code>prob_oops = 1 - prob_fine\n\nprob_fine =   Σ  prob_error·prob_detect_error + (1 - prob_error)\n            error\n            types\n\nprob_error = 1 - (1 - prob_char_error) ^ #chars\n</code></pre>\n<ul>\n<li><code>prob_error</code> is the probability that the human committed at least one error of\nthat type over the whole text.</li>\n<li><code>prob_char_error</code> is the probability of committing that type of error on a\ngiven character. It depends on the type of error, and <code>α</code>, the size of the\nalphabet used: the more symbols there are, the more they look alike.</li>\n<li><code>prob_detect_error</code> is the probability that the error gets detected. It\ndepends on the type of error. It is <code>1-prob_collision</code>, the probability that\nthe checksum yields the same result for two inputs separated by an error of a\ngive type.</li>\n<li><code>#chars</code>: payload size. To transmit b bits of information, it is\n<code>⌈b ÷ log2(α)⌉ + checksum size</code>.</li>\n</ul>\n<p>We can get the probability of a single-character substitution, for instance,\nfrom the probability <code>p</code> of a substitution on a text holding <code>b</code> bits:</p>\n<pre><code>prob_char_error = 1 - 2 ^ (log2(1 - p) ÷ ⌈b ÷ log2(α)⌉)\n</code></pre>\n<p>So, all we need, to find an optimal <code>α</code> and <code>checksum size</code>, is <strong>a user study\nestimating the probability of human mistakes</strong>.</p>\n<p>…</p>\n<script type=\"application/ld+json\">\n{ \"@context\": \"http://schema.org\",\n  \"@type\": \"BlogPosting\",\n  \"datePublished\": \"2019-04-29T14:18:51Z\",\n  \"keywords\": \"hash\" }\n</script>\n",
      },
      {
        "id":  "https://espadrine.github.io/blog/posts/how-to-implement-go.html",
        "url": "https://espadrine.github.io/blog/posts/how-to-implement-go.html",
        "title": "How to implement Go",
        "tags": "baduk ai",
        "date_published": "2018-10-26T19:12:17Z"
        "content_html": "<h1>How to implement Go</h1>\n<p>As I wanted to make an automated Go player, as I planned <a href=\"http://espadrine.github.io/blog/posts/a-go-browser-battle.html\">on a previous\narticle</a>, I first needed a full implementation of the game\nof Go.</p>\n<p>Go is a beautiful, tremendously old game with very simple rules and yet\ntremendous subtlety. Here are the rules:</p>\n<ol>\n<li>Each of two players, black or white, take turns either passing or placing a\nstone of their color on an intersection of a 19×19 board, starting with\nblack.</li>\n<li>A <strong>group</strong> is a set of stones that are next to each other (up, down, left or\nright), or next to a stone that is in the group. A group’s <strong>liberties</strong> are\nthe number of disctinct empty intersections next to the group’s stones. When\na player places a stone, all enemy groups that no longer have any liberties\nare <strong>captured</strong>: they are removed from the board.</li>\n<li>A player is not allowed to place a stone if it causes the start of next turn\nto include a group with no liberties. That forbids <strong>suicides</strong>.</li>\n<li>A player is not allowed to place a stone if it causes the start of next turn\nto have a board configuration that already occurred during the game. This is\nknown as a <strong>Ko</strong> when the configuration happened on the previous turn, and\nas a <strong>Superko</strong> more generally. It ensures that games must end; there are no\ndraws.</li>\n<li>When nobody can add stones, the player with the most stones, enclosed\nintersections (aka. <strong>territory</strong>), captured stones, and <strong>Komi</strong> (an added\nbonus to white to compensate for the asymmetry of who starts first), wins.\nThe Komi usually has a half point to ensure that there can be no equal\nscores, again to forbid draws.</li>\n</ol>\n<h2>The board</h2>\n<p><img src=\"https://thefiletree.com/metaboard/go/blog/how-to-implement-go/capture.png\" alt=\"AlphaGo vs. AlphaGo game, where white is about to capture 66 stones.\" /></p>\n<p>Since the board is a compact 2-dimensional space, we use an array, with each\nslot containing an intersection which includes its state (empty, with a white\nstone, etc.) and historical and analytical information for use by the learning\nsystems: whether it is a legal move, when it last received a move, whether it is\nthe <strong>atari</strong> liberty of a group, ie. the move that captures the group, and how\nmany stones it captures.</p>\n<p>We also keep track of all groups on the board. Each intersection links to its\ngroup, and the group maintains a set of its stones, and another of its\nliberties. When registering a move, groups are updated. It is fast, since at\nmost four groups may need updating.</p>\n<p>There is some logic to merge groups together, destroying the original groups,\nand creating a new one that contains the union of the previous ones. It is not\nparticularly fast (and could likely be improved by keeping the largest group and\nadding the others to it), but since merging groups does not happen on every\nturn, it did not seem to matter that much for now.</p>\n<p>Counting final or partial points also requires maintaining territory\ninformation. Yet again, we use a set to keep the intersections, and each move\nupdates the territory information corresponding to its surroundings.</p>\n<h2>Play</h2>\n<p>The most complicated function is inevitably the logic for computing a move. We\nmust look at surrounding intersections and their groups, to assess whether the\nmove is a suicide (and therefore invalid), and when it captures enemy stones.</p>\n<p>Most operations are essentially constant-time, apart from group merging, since\nthe number of impacted groups is bounded, and all operations are set updates.</p>\n<h2>Superko</h2>\n<p>Detecting a match into previous board configurations is probably the trickier\npart of the system. Fortunately, a subtle algorithm for it already exists:\n<strong>Zobrist hashing</strong>.</p>\n<p>It relies on a smart hashing system, where each possible board configuration is\nmapped to a unique hash. Trivial hashes would be too slow: your first guesses\nfor a hash probably require to read the whole board. Instead, a Zobrist hash is\nsimilar to a rolling hash, in that it only needs a single update to account for\nthe forward change.</p>\n<p>You start with a hash of zero for the blank board. When initializing the board,\nyou generate a random 64-bit value (or, when you are like me and use JS, a\n32-bit integer) for each intersection on the board, and for each move that can\nbe made on that position (place a black stone, or place a white stone).</p>\n<p>To compute the hash for a new board configuration, you take the hash of the\nprevious board. For every change on the board, you XOR the previous hash with\nthe random value associated with this particular change.</p>\n<p>For instance, if you place a black stone on A19 and it captures a white stone on\nB19, you will XOR the hash with the random value for “black A19”, and then XOR\nit with “white B19”. <em>Fun fact</em>: it yields the same value if you do it the other\nway around.</p>\n<h2>Score</h2>\n<p>The bulk of scoring is establishing territories. To make things simple, we\nassume the game went to its final conclusion, where there are no gray zones. All\nregions are either surrounded by white or black, and there are no capturable\nstones left.</p>\n<p>All that remains is to go through intersections in reading order, top to bottom,\nleft to right, and to stitch each empty spot to its neighbor territories,\npotentially joining two larger territories together if necessary. Any stone that\nis next to the territory gives it its color.</p>\n<p>It makes counting points fairly easy: add komi, capture, stones on board, and\nown territory, and the trick is done.</p>\n<h2>Ongoing</h2>\n<p>Having implemented the game rules is not enough to properly train bots on it.</p>\n<p>For starters, we need an <strong>SGF parser</strong> to extract information about the moves\nof existing games. SGF (Simple Game Format) is the main format for serializing\nGo games.</p>\n<p>Then, we want to support <strong>GTP</strong>: the Go Text Protocol is the most common format\nfor transmitting remote commands between a Go implementation and a robot player.</p>\n<p>Finally, we will explore various techniques for AI design.</p>\n<p>Expect fun!</p>\n<script type=\"application/ld+json\">\n{ \"@context\": \"http://schema.org\",\n  \"@type\": \"BlogPosting\",\n  \"datePublished\": \"2018-10-26T19:12:17Z\",\n  \"keywords\": \"baduk, ai\" }\n</script>\n",
      },
      {
        "id":  "https://espadrine.github.io/blog/posts/file-system-object-storage.html",
        "url": "https://espadrine.github.io/blog/posts/file-system-object-storage.html",
        "title": "Insanities of a File System Object Storage",
        "tags": "storage posix",
        "date_published": "2018-05-31T19:42:00Z"
        "content_html": "<h1>Insanities of a File System Object Storage</h1>\n<p><em>(TL;DR: I present <a href=\"https://www.npmjs.com/package/fsos\">fsos</a>; but read on to know why.)</em></p>\n<p>How do you update a file in Node.js?</p>\n<p>Well, let’s browse our dear <a href=\"https://nodejs.org/api/fs.html\">file system API</a>…</p>\n<pre><code class=\"language-js\">fs.writeFile(file, data)\n</code></pre>\n<p>Simple enough, isn’t it?</p>\n<p>And yet, there are so many kinds of wrong in this seemingly obvious answer.</p>\n<h2>POSIX</h2>\n<p>Let’s first educate ourselves. Node.js’ file system API is designed to imitate\nand target POSIX, a specification to etch the core Unix experience in granite.\nWhile the main reason for the success of Unix was portability, ensuring that\nuserland programs could run on different machines, the three tenets of its\ndesign were also delicious (<strong>plain text</strong> as universal interface, composable\nprograms via a <strong>shell</strong>, and a <strong>hierarchical file system</strong> offering a unified\ninterface to kernel functionality (not just data storage)).</p>\n<p>Naturally, everybody stole those juicy ideas. When Richard Stallman famously\nchose to write a free operating system to oppose what we would today call DRM,\nhe wanted Unix compatibility. When compatibility is seeked, standardization\nbecomes necessary. IEEE sprung into action in the form of SUS (the Single Unix\nSpecification), and, with Richard’s suggested name, wrote the Portable Operating\nSystem Interface, <strong>POSIX</strong>.</p>\n<p>Richard’s baby, <strong>GNU</strong>, had little impact without a proper kernel. It was a\nmere collection of programs that would talk to a Unix file system if there was a\nfree one. Fortunately, a free one arose, birthed as <strong>Linux</strong>, and gained major\nadoption thanks to its sweet mix of speed, stability, and a healthy dose of\nbright experiments. When <strong>Node.js</strong> was created, Linux was the overwhelming\nking of the server-side, which Node.js wanted to conquer.</p>\n<p>In a way, the reason that the obvious one-liner above doesn’t work is Unix’\nfault. It designed file interaction in a manner that made a lot of sense for\nsome uses of the file system, disregarding others. Behind the covers, each\nfile is a mere set of contiguous disk space (blocks, extents, or sectors) that\npoint to each other, so it stands to reason that appending data at the end is\nprobably faster than appending it at the beginning, just as it is with a diary.</p>\n<p>The standard C library defined by POSIX reflects the internal design of Unix\nfile systems without hiding its flaws. Consequence: internally non-obvious\noperations have non-obvious solutions, and non-solutions that are as tempting to\nuse as a chocolate cookie (up until your tongue warns you that it was in fact\nraisins).</p>\n<p>The most critical interface for file operations is <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html\">open</a>. It returns a file\ndescriptor to operate the file. It takes a handful of required flags and a ton\nof optional ones. Most famous amongst the required ones are <code>O_RDONLY</code> if you\nwill only read, <code>O_WRONLY</code> if you don’t feel like reading anymore, and <code>O_RDWR</code>\nif you hate picking a side.</p>\n<p>Among the optional flags, <code>O_CREAT</code> creates the file automatically if it doesn’t\nexist, <code>O_TRUNC</code> empties the file, and <code>O_APPEND</code> forces you to write only at\nthe end. (What a coincidence that appending is both fast in file systems and\nhas a shortcut!)</p>\n<p>However, most people use <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/fopen.html\">fopen</a>, a layer on top of <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html\">open</a>, which\nunfortunately has very strange defaults. Instead of the flags we understand, it\nhas string modes that seem to mean something they do not do. Here are the\nnonsensical rules.</p>\n<ul>\n<li><code>&quot;r&quot;</code> is the only one that prevents writing,</li>\n<li>If the string has an <code>r</code>, it doesn’t create a file automatically,</li>\n<li>If the string does not have a <code>+</code>, it cannot both read and write,</li>\n<li>If the string has a <code>w</code>, it empties the file,</li>\n<li>If the string has an <code>a</code>, all writes append to the file (finally one that\ndoes what is on the cover!)</li>\n</ul>\n<p>For instance, <code>&quot;r+&quot;</code> can write, but won’t create a file automatically for some\nreason.</p>\n<p>The modes offered by <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/fopen.html\">fopen</a> barely target what people actually do with a\nfile:</p>\n<ol>\n<li>Read a configuration file: <code>&quot;r&quot;</code>,</li>\n<li>Write logs: <code>&quot;a&quot;</code>,</li>\n<li>Update a whole file: nothing.</li>\n</ol>\n<p>For more precise operations, use <code>&quot;r+&quot;</code>. All other possibilities are most likely\nbugs waiting to be found. Special mention to <code>&quot;w+&quot;</code> which empties the file it\nallows you to read! In fact, the main lesson of this blog post is that <code>O_TRUNC</code>\nhas only one, very rare, use-case: <em>emptying a file, without removing it,\nwithout writing to it</em>. You should essentially never use <code>&quot;w&quot;</code>.</p>\n<p>Naturally, Node.js favours <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/fopen.html\">fopen</a>-style modes, instead of the more elegant\n<a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html\">open</a>.</p>\n<p>Naturally, its default mode for write operations is the useless <code>&quot;w&quot;</code>.</p>\n<h2>Async IO</h2>\n<p>Now that we have background information, let’s dig into the first issue.</p>\n<p>A long-standing problem in HTTP server software is <a href=\"http://www.kegel.com/c10k.html\">C10K</a>, ie. hitting 10k\nconcurrent clients to serve with a single machine. A large part of beating that\nfigure is dealing with how slow IO is. Fetching a file on disk takes a long\ntime! And by default, POSIX system calls make your program wait for the file to\nbe read, and your program just sits there doing nothing in the meantime, like a\npassenger waiting for the bus to come.</p>\n<p>Fortunately, POSIX includes a special switch to avoid waiting: <code>O_NONBLOCK</code>. It\nis part of <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html\">open</a>. When an IO operation is performed, you can do whatever you\nwant, even though the operation is not done. Later on, you can call <code>poll()</code> or\n<code>select()</code> or <code>kqueue()</code> (depending on the OS you use), and learn whether the\noperation is done.</p>\n<p>Node.js’ <em>raison d’être</em> was completely focused on how easy JS makes\nasynchronous operations. Their whole file system interface recommends using the\nnon-blocking API. But in some cases, it makes zero sense. So it is with\n<code>fs.writeFile()</code>. It <em>never</em> does what you want. Not with the default\nparameters, anyway.</p>\n<p>When you use storage, you implicitly expect some level of consistency. If you\nwrite ‘hello’ to a file which contains ‘hi’ and then immediately read from it,\nyou don’t expect to read ‘who is this?’ if absolutely nobody wrote to the file\nin the meantime. You expect ‘hello’ — or, at least, ‘hi’. But here, you will\nread neither what was in the file before, nor what you wrote in it.</p>\n<pre><code class=\"language-js\">var fs = require('fs')\nvar fn = './foo'  // file name\nfs.writeFileSync(fn, '1234\\n')\nfs.createReadStream(fn).pipe(process.stdout)  // → 1234\nfs.writeFile(fn, '2345\\n')\nfs.createReadStream(fn).pipe(process.stdout)  // The file is empty.\n</code></pre>\n<p>This is the code I submitted as <a href=\"https://github.com/nodejs/node-v0.x-archive/issues/7807\">an issue</a> to Joyent’s node (prior to\nthe io.js fork).</p>\n<p>So what is going on? Why does it break your implicit consistency expectations?\nIt turns out that the operations you use are not atomic. What <code>fs.writeFile()</code>\nreally means is “Empty the file immediately, and some day, please fill it with\nthis.” In POSIX terms, you perform an\n<code>open(…, O_WRONLY|O_CREAT|O_TRUNC|O_NONBLOCK)</code>, and the <code>O_TRUNC</code> empties the\nfile. Since it is <code>O_NONBLOCK</code>, the next line of code gets executed immediately.\nThen, Node.js’ event loop spins: on the next tick, it polls, and the file system\ntells it that it is done (and indeed, it is). Note that it can take many more\nevent loop ticks, if there is a larger amount of data written.</p>\n<p>Fundamentally, why would you ever want those default flags (aka. <code>fopen</code>’s\n<code>'w'</code>)? If you are writing logs or uploading a file to the server, you want\n<code>'a'</code> instead; if you are updating configuration files or any type of data, you\nwant… something that will be described in the next chapter. For any type of file\nthat has the risk of being read, this default flag is the wrong one to use.</p>\n<p>So, the problem is that it was non-blocking, right? After all, if we change it\nto be synchronous, it all seems to work, right?</p>\n<pre><code class=\"language-js\">var fs = require('fs')\nvar fn = './foo'  // file name\nfs.writeFileSync(fn, '1234\\n')\nfs.createReadStream(fn).pipe(process.stdout)  // → 1234\nfs.writeFileSync(fn, '2345\\n')\nfs.createReadStream(fn).pipe(process.stdout)  // → 2345\n</code></pre>\n<p>Don’t you hate it when you read a blog post, and the author ends two\nconsecutive sentences with “right?”, and you just know it means “false!”</p>\n<h2>File Systems</h2>\n<p>What if your application crashes?</p>\n<p>Having your app crash just after you opened the file for writing, but before it\nis done writing, will unsurprisingly result in a half-written file — or an empty\none. Since the memory of the crashed app is reclaimed, the data that was not\nwritten is lost forever!</p>\n<p>You want to <em>replace a file</em>. Therefore, even if the application crashes, you\nwant to make sure that you maintain either the old version, or the new version,\nbut not an in-between. <code>fs.writeFileSync()</code> does not offer that guarantee, just\nas the underlying POSIX primitives. It is tempting, but wrong.</p>\n<p>In <a href=\"http://thunk.org/tytso/blog/2009/03/12/delayed-allocation-and-the-zero-length-file-problem/comment-page-5/#comment-2782\">the words</a> of Theodore Ts’o, maintainer of ext4, the most used\nfile system on Linux and possibly in the world (and creator of <code>/dev/random</code>):</p>\n<blockquote>\n<p>Unfortunately, there very many application programmers that attempt to update an existing file’s contents by opening it with O_TRUNC. I have argued that those application programs are broken, but the problem is that the application programmers are “aggressively ignorant”, and they outnumber those of us who are file system programmers.</p>\n</blockquote>\n<p>The fundamental issue is that <code>fs.writeFileSync()</code> is not atomic. It is a series\nof operations, the first of which deletes the old version of the file, the next\nones slowly inserting the new version.</p>\n<p>What do we want? The new version! When do we want it? Once written on disk,\nobviously. We have to first write the new version on disk, alongside the old\none, and then switch them. Fortunately, POSIX offers a primitive that performs\nthat switch <em>atomically</em>. World, meet <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/rename.html\"><code>rename()</code></a>.</p>\n<pre><code class=\"language-js\">var tmpId = 0\nvar tmpName = () =&gt; String(tmpId++)\nvar replaceFile = (file, data, cb) =&gt; {\n  var tmp = tmpName()\n  fs.writeFile(tmp, data, err =&gt; {\n    if (err != null) { cb(err); return }\n    fs.rename(tmp, file, cb)\n  })\n}\n</code></pre>\n<p>Obviously, I simplify a few things in this implementation:</p>\n<ul>\n<li>We have to verify that the <code>tmp</code> file does not exist,</li>\n<li>We should make <code>tmp</code> have a UUID to reduce the risk that another process\ncreates a file with the same name between the moment we check for its\nexistence and the moment we write to it,</li>\n<li>We said before that Node.js was using <code>'w'</code> as the default write flag; we want\nto use at least <code>'wx'</code> instead. <code>x</code> is a Node.js invention that uses <code>O_EXCL</code>\ninstead of <code>O_TRUNC</code>, so that the operation fails if the file already exists\n(we would then retry with a different UUID),</li>\n<li>We need to create <code>tmp</code> with the same permissions as <code>file</code>, so we also need\nto <code>fs.stat()</code> it first.</li>\n</ul>\n<p>All in all, the finished implementation is nontrival. But this is it, right?\nThis is the end of our ordeal, right? We finally maintained consistency, right?</p>\n<p>I have good news! According to POSIX, yes, this is the best we can do!</p>\n<h2>Kernel Panics</h2>\n<p>We settled that <em>write temporary then rename</em> survives app crashes under\nPOSIX. However, there is no guarantee for system crashes! In fact, POSIX gives\nabsolutely no way to maintain consistency across system crashes with certainty!</p>\n<p>Did you really think that being correct according to POSIX was enough?</p>\n<p>When Linux used ext2 or ext3, app developers used <em>truncate then write</em> or the\nslightly better <em>write temporary then rename</em>, and everything seemed fine,\nbecause system crashes are rare. Then a combination of three things happened:</p>\n<ul>\n<li>Unlike ext3, ext4 was developed with <strong>delayed allocation</strong>: writes are\nperformed in RAM, then it waits for a few seconds, and only then does it apply\nthe changes to disk. It is great for performance when apps write too often.</li>\n<li>GPU vendors started writing drivers for Linux. Either they didn’t care much\nabout their Linux userbase, or all their drivers are faulty: the case remains\nthat <strong>those drivers crashed a lot</strong>. And yet, the drivers are part of the\nkernel: they cause system crashes, not recoverable application crashes.</li>\n<li><strong>Desktop Linux</strong> users started playing games.</li>\n</ul>\n<p>What had to happen, happened: a user played a game that crashed the system, at\nwhich point all files that had been updated in the past 5 seconds were zeroed\nout. Upon reboot, the user had lost a lot of data.</p>\n<p>There were a lot of sad Linux users and grinding of teeth. As a result, Theodore\nTs’o <a href=\"http://thunk.org/tytso/blog/2009/03/12/delayed-allocation-and-the-zero-length-file-problem/\">patched</a> the kernel to detect when apps update files\nthe wrong way (ie, both <em>truncate then write</em> and <em>write temporary then\nrename</em>), and disabled delayed allocation in those cases.</p>\n<p>Yes. <em>Write temporary then rename</em> is also the wrong way to update a file. I\nknow, it is what I just advised in the previous section! In fact, while POSIX\nhas no way to guarantee consistency for file updates, here is the closest thing\nyou’ll get:</p>\n<ol>\n<li>Read the file’s permissions.</li>\n<li>Create a temporary file in the same directory, with the same permissions,\nusing <code>O_WRONLY</code>, <code>O_CREAT</code> and <code>O_EXCL</code>.</li>\n<li>Write to the new file.</li>\n<li><a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/fsync.html\"><code>fsync()</code></a> that file.</li>\n<li>Rename the file over the file you want to update.</li>\n<li><code>fsync()</code> the file’s directory.</li>\n</ol>\n<p>Isn’t it <a href=\"http://thunk.org/tytso/blog/2009/03/15/dont-fear-the-fsync/\">obvious</a> in retrospect?</p>\n<p><em>Renaming the file before it is <code>fsync</code>’ed</em> creates a window of time where a\ncrash would make the directory point to the updated file, which isn’t committed\nto disk yet (as it was in the file system cache), and so the file is empty or\ncorrupt.</p>\n<p>Less harmful, <em>a crash after renaming and before the directory’s cache is\nwritten to disk</em> would make it point to the location of the old content. It\ndoesn’t break atomicity, but if you only want to perform some action after the\nfile was replaced <em>for sure</em>, you would better <code>fsync</code> that directory before you\ndo something you will regret. It might seem like nothing, but it can break your\nassumptions of data consistency.</p>\n<p>If you own an acute sense of observation, you noticed that, while Theodore’s\npatch makes it less likely that “badly written file updates” will cause files to\nbe zeroed out upon a system crash, the bug always existed and still exists! The\ntimespan where things can go horribly wrong is only reduced. The fault is\nrejected on the app developers.</p>\n<p>This issue was “fixed” — well, the patch landed at least — in Linux 2.6.30 on\nthe most common file systems (ext4 and btrfs).</p>\n<h2>Conclusion</h2>\n<p>Here’s one thing to get away from all this: file systems have a design which\nworks well with certain operations and… not so well… with others. <strong>Replacing a\nfile is costly!</strong> You should know what you are doing (or use <a href=\"https://www.npmjs.com/package/fsos\">fsos</a>, my npm\nlibrary which wraps all of this in sweet promises), and only replace files at\nworst a few times a second. Ideally a lot less often, especially for large\nfiles.</p>\n<p>Realistically, though, what you fundamentally want is not to lose work that is\nolder than X seconds, for some value of X that is thankfully often larger than\na half.</p>\n<p>Besides, this is Node.js. One issue that is common elsewhere with a trivial\nimplementation is that the main thread waits for the I/O to be finished before\nit can move on. In Node.js, we get asynchrony for free. The file replacement\nhappens essentially in the background. The main thread stays as responsive as a\nhappy antelope!</p>\n<p>PS: I feel like I should also advocate for a few things. For every mistake,\nthere is both a lesson and a prevention; we have only just learned the lesson.\nProgrammers go to the path of least resistance, and what they face encourages\nthem to the pit of death. I see two splinters to remove:</p>\n<ol>\n<li>Linux should offer an atomic file replacement operation that does it all\nright. Theodore argues that it is glib’s (and other libraries’) task, but I\ndisagree. To me, one of the most common file operations doesn’t have its\nsyscall.</li>\n<li>Node.js’ defaults ought to be improved. <code>fs.writeFile()</code> heavily suggests\nbeing used for file updates, and has the default flag of <code>'w'</code>. It is a terribly\nill-advised primitive for any use. It should be replaced by <code>'ax'</code>, but it\ncannot, because of legacy! I recommend having a warning, and a separate\n<code>fs.updateFile()</code> function.</li>\n</ol>\n<script type=\"application/ld+json\">\n{ \"@context\": \"http://schema.org\",\n  \"@type\": \"BlogPosting\",\n  \"datePublished\": \"2018-05-31T19:42:00Z\",\n  \"keywords\": \"storage, posix\" }\n</script>\n",
      }
  ]
}
