{
  "version": "https://jsonfeed.org/version/1",
  "title": "Espadrine’s blog",
  "description": "Let’s talk about whatever I learn!",
  "home_page_url": "https://espadrine.github.io/blog/",
  "feed_url": "https://espadrine.github.io/blog/feed.json",
  "author": {
    "name": "Thaddée Tyl",
    "url": "https://github.com/espadrine"
  },
  "favicon": "https://avatars.githubusercontent.com/u/100689?s=64",
  "items": [
      {
        "id":  "https://espadrine.github.io/blog/posts/two-postgresql-sequence-misconceptions.html",
        "url": "https://espadrine.github.io/blog/posts/two-postgresql-sequence-misconceptions.html",
        "title": "Two PostgreSQL Sequence Misconceptions",
        "tags": "hash",
        "date_published": "2019-09-05T17:28:59Z"
        "content_html": "<h1>Two PostgreSQL Sequence Misconceptions</h1>\n<p>✨ <em>With Examples!</em> ✨</p>\n<p>Some constructs seem more powerful than the promises they make.</p>\n<p>PostgreSQL sequences are like that. Many assume it offers stronger properties\nthan it can deliver.</p>\n<p>They trust them to be the grail of SQL ordering, the one-size-fits-all of strict\nserializability. However, there is a good reason Amazon spent design time on\nvector clocks in <a href=\"https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf\">Dynamo</a>, Google invested significantly into <a href=\"https://static.googleusercontent.com/media/research.google.com/en//archive/chubby-osdi06.pdf\">Chubby</a>, then\n<a href=\"https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36726.pdf\">Percolator</a>’s timestamp oracle, then <a href=\"https://static.googleusercontent.com/media/research.google.com/en//archive/spanner-osdi2012.pdf\">Spanner</a>’s expensive,\natomic-clock-based TrueTime; why Twitter built <a href=\"https://developer.twitter.com/en/docs/basics/twitter-ids.html\">Snowflake</a>, and so many others\nbuilt custom timestamp systems.</p>\n<ol>\n<li>Strict serializability is hard to achieve, especially in a distributed\nsystem, but even in a centralized system with the possibility of failure.</li>\n<li>Developers assume the system is strict-serializable, but it usually is not.</li>\n<li>When a system provides timestamps, developers will use those as if they were\nmonotonically strictly increasing atomically throughout the distributed\nsystem, but they often are not, which causes subtle bugs.</li>\n</ol>\n<h2>The problem space</h2>\n<p>To design your system’s properties right, it is often useful or necessary to\ndetermine the order in which events happened. Ideally, you wish for the <strong>“wall\nclock” order</strong> (looking at your watch), although instantaneity gets tricky when\nevents occur at a distance, even within the same motherboard, but especially\nacross a datacenter, or between cities.</p>\n<p>At the very least, you want to reason about <strong>causal ordering</strong>: when that event\nhappened, did it already see this other event?</p>\n<p>A nice property to have, even for a single centralized database, is to give a\nmonotonically increasing identifier for each row. Most PostgreSQL users rely on\nthe <code>SERIAL</code> type for that – a sequence. Each insertion will call <code>nextval()</code>\nand store an increasing value.</p>\n<p>What you implicitly want is to list rows by insertion order, Your mental model\nis that each insertion happens at a set “wall clock” time. A first insertion\nwill happen at T0 and set the identifier 1, the next one happens at T1 and get\nnumber 2, and so on. Therefore, <em>you expect a row with ID N to have causally\nbeen inserted after a row with ID M &lt; N</em>.</p>\n<p>Operational order is a consistency constraint strongly associated with isolation\nlevels. A PostgreSQL database can handle multiple simultaneous operations.</p>\n<p><em>(Side note: I could be talking about threads and locks, but I will not, because\nthose are just tools to achieve properties. PostgreSQL may switch tools to\nbetter meet a given promise (they did so with the serializable level in 2011),\nbut the promise won’t change.)</em></p>\n<p>By default, it promises <strong>Read Committed</strong> isolation: a transaction can witness\nthe effects of all transactions that commit “before” it does (but not those that\nhave not committed yet). Their commits are therefore causally ordered by commit\ntime.</p>\n<p>However, nothing else within a transaction has any causal promise with respect\nto other transactions. The same <code>SELECT</code> can yield different values;\nsimultaneous insertions can happen either before, after, or anything in between,\nyour own insertion.</p>\n<p>The highest isolation level PostgreSQL offers is <strong>Serializable</strong> isolation: all\ntransactions are causally ordered; from <code>BEGIN</code> to <code>COMMIT</code>. Of course,\ntransactions still execute in parallel; but the database makes sure that\neverything that a transaction witnesses can be explained by executing all its\nstatements either after all statements of another transaction, or before all of\nthem. It won’t see a changing state within the execution of the transaction.</p>\n<p><em>(By the way, PostgreSQL only achieved serializability in 2011, when they\nreleased <a href=\"https://www.postgresql.org/docs/release/9.1.0/\">version 9.1</a> with support for predicate locks. It is hard)</em></p>\n<p>Having a causal order does not mean that this order follows <em>real time</em>: one\ninsertion may complete at 9:30am <em>after (in causal order)</em> another that\ncompletes at 10:40am. If you want the additional property that the order is\nconsistent with wall clock time, you want <strong><a href=\"https://jepsen.io/consistency/models/strict-serializable\">Strict Serializability</a></strong>.</p>\n<p>However, <strong>PostgreSQL makes no claim of Strict Serializability</strong>.</p>\n<p>Given all this, sequences probably feel much weaker than you initially thought.</p>\n<p>You want them to give a continuous set of numbers, but a sequence can yield\nvalues with gaps (1 2 4).</p>\n<p>You want them to give a causal order <em>(2 was inserted before 3)</em>, but it can\nyield values out of order (1 3 2).</p>\n<p>All a sequence promises is to give values that have an order. Not a continuous\norder, nor a time order.</p>\n<p>Let’s demonstrate both.</p>\n<h2>Gaps</h2>\n<p>Let’s create a table with a <code>SERIAL</code> identifier. For the purpose of showing\nthings going right, let’s insert a row.</p>\n<pre><code class=\"language-sql\">CREATE TABLE gaps (id SERIAL);\nBEGIN;\nINSERT INTO order DEFAULT VALUES;\nSELECT * FROM gaps;\n</code></pre>\n<pre><code> id \n----\n  1\n(1 row)\n</code></pre>\n<p>Now comes the gap.</p>\n<pre><code class=\"language-sql\">BEGIN;\nINSERT INTO order DEFAULT VALUES;\nROLLBACK;\n</code></pre>\n<p>Since we rolled back, nothing happened – or did it?</p>\n<p>Let’s now insert another row.</p>\n<pre><code class=\"language-sql\">INSERT INTO order DEFAULT VALUES;\nSELECT * FROM gaps;\n</code></pre>\n<pre><code> id \n----\n  1\n  3\n(2 rows)\n</code></pre>\n<p>Oops! Despite the rollback, the sequence was incremented without being reverted.\nNow, there is a gap.</p>\n<p>Let’s now break the other assumption.</p>\n<h2>Order violation</h2>\n<p>First, a table with a sequence and a timestamp:</p>\n<pre><code class=\"language-sql\">CREATE TABLE orders (id SERIAL, created_at TIMESTAMPTZ);\n</code></pre>\n<p>Let’s set up two concurrent connections to the database. Each will have the same\ninstructions. I started the first one yesterday:</p>\n<pre><code class=\"language-sql\">-- Connection 1\nBEGIN;\n</code></pre>\n<p>I launch the second one today:</p>\n<pre><code class=\"language-sql\">-- Connection 2\nBEGIN;\nINSERT INTO orders (created_at) VALUES (NOW());\nCOMMIT;\n</code></pre>\n<p>Let’s go back to the first one:</p>\n<pre><code class=\"language-sql\">-- Connection 1\nINSERT INTO orders (created_at) VALUES (NOW());\nCOMMIT;\n</code></pre>\n<p>Simple enough. But we actually just got the order violation:</p>\n<pre><code class=\"language-sql\">SELECT * FROM orders ORDER BY created_at;\n</code></pre>\n<pre><code> id |          created_at           \n----+-------------------------------\n  2 | 2019-09-04 21:10:38.392352+02\n  1 | 2019-09-05 08:19:34.423947+02\n</code></pre>\n<p>The order of the sequence does not follow creation order.</p>\n<h2>Are we doomed?</h2>\n<p>No.</p>\n<p>Sure, the systems we use have weak assumptions. But that is true at every level.\nThe nice thing about the world is that you can combine weak things to make\nstrong things. Pure iron is ductile, and carbon is brittle, but their alloy is\nsteel.</p>\n<p>For instance, you can get the best of both worlds, causal order and “wall clock”\ntimestamps, by having a <code>TIMESTAMPTZ</code> field, only inserting rows within\nserializable transactions, and setting the <code>created_at</code> field to now, or after\nthe latest insertion:</p>\n<pre><code class=\"language-sql\">BEGIN ISOLATION LEVEL SERIALIZABLE;\nINSERT INTO orders (created_at)\nSELECT GREATEST(NOW(), MAX(created_at) + INTERVAL '1 microsecond') FROM orders;\nCOMMIT;\n</code></pre>\n<p>Indeed, PostgreSQL’s <code>TIMESTAMPTZ</code> has a precision up to the microsecond. You\ndon’t want to have conflicts in your <code>created_at</code> (otherwise you could not\ndetermine causal order between the conflicting rows), so you add a microsecond\nto the current time if there is a conflict.</p>\n<p>It does mean that concurrent insertions will likely fail, as they will each\nacquire a (non-blocking) SIReadLock on the relation.</p>\n<script type=\"application/ld+json\">\n{ \"@context\": \"http://schema.org\",\n  \"@type\": \"BlogPosting\",\n  \"datePublished\": \"2019-09-05T17:28:59Z\",\n  \"keywords\": \"hash\" }\n</script>\n",
      },
      {
        "id":  "https://espadrine.github.io/blog/posts/how-to-implement-go.html",
        "url": "https://espadrine.github.io/blog/posts/how-to-implement-go.html",
        "title": "How to implement Go",
        "tags": "baduk ai",
        "date_published": "2018-10-26T19:12:17Z"
        "content_html": "<h1>How to implement Go</h1>\n<p>As I wanted to make an automated Go player, as I planned <a href=\"http://espadrine.github.io/blog/posts/a-go-browser-battle.html\">on a previous\narticle</a>, I first needed a full implementation of the game\nof Go.</p>\n<p>Go is a beautiful, tremendously old game with very simple rules and yet\ntremendous subtlety. Here are the rules:</p>\n<ol>\n<li>Each of two players, black or white, take turns either passing or placing a\nstone of their color on an intersection of a 19×19 board, starting with\nblack.</li>\n<li>A <strong>group</strong> is a set of stones that are next to each other (up, down, left or\nright), or next to a stone that is in the group. A group’s <strong>liberties</strong> are\nthe number of disctinct empty intersections next to the group’s stones. When\na player places a stone, all enemy groups that no longer have any liberties\nare <strong>captured</strong>: they are removed from the board.</li>\n<li>A player is not allowed to place a stone if it causes the start of next turn\nto include a group with no liberties. That forbids <strong>suicides</strong>.</li>\n<li>A player is not allowed to place a stone if it causes the start of next turn\nto have a board configuration that already occurred during the game. This is\nknown as a <strong>Ko</strong> when the configuration happened on the previous turn, and\nas a <strong>Superko</strong> more generally. It ensures that games must end; there are no\ndraws.</li>\n<li>When nobody can add stones, the player with the most stones, enclosed\nintersections (aka. <strong>territory</strong>), captured stones, and <strong>Komi</strong> (an added\nbonus to white to compensate for the asymmetry of who starts first), wins.\nThe Komi usually has a half point to ensure that there can be no equal\nscores, again to forbid draws.</li>\n</ol>\n<h2>The board</h2>\n<p><img src=\"https://thefiletree.com/metaboard/go/blog/how-to-implement-go/capture.png\" alt=\"AlphaGo vs. AlphaGo game, where white is about to capture 66 stones.\" /></p>\n<p>Since the board is a compact 2-dimensional space, we use an array, with each\nslot containing an intersection which includes its state (empty, with a white\nstone, etc.) and historical and analytical information for use by the learning\nsystems: whether it is a legal move, when it last received a move, whether it is\nthe <strong>atari</strong> liberty of a group, ie. the move that captures the group, and how\nmany stones it captures.</p>\n<p>We also keep track of all groups on the board. Each intersection links to its\ngroup, and the group maintains a set of its stones, and another of its\nliberties. When registering a move, groups are updated. It is fast, since at\nmost four groups may need updating.</p>\n<p>There is some logic to merge groups together, destroying the original groups,\nand creating a new one that contains the union of the previous ones. It is not\nparticularly fast (and could likely be improved by keeping the largest group and\nadding the others to it), but since merging groups does not happen on every\nturn, it did not seem to matter that much for now.</p>\n<p>Counting final or partial points also requires maintaining territory\ninformation. Yet again, we use a set to keep the intersections, and each move\nupdates the territory information corresponding to its surroundings.</p>\n<h2>Play</h2>\n<p>The most complicated function is inevitably the logic for computing a move. We\nmust look at surrounding intersections and their groups, to assess whether the\nmove is a suicide (and therefore invalid), and when it captures enemy stones.</p>\n<p>Most operations are essentially constant-time, apart from group merging, since\nthe number of impacted groups is bounded, and all operations are set updates.</p>\n<h2>Superko</h2>\n<p>Detecting a match into previous board configurations is probably the trickier\npart of the system. Fortunately, a subtle algorithm for it already exists:\n<strong>Zobrist hashing</strong>.</p>\n<p>It relies on a smart hashing system, where each possible board configuration is\nmapped to a unique hash. Trivial hashes would be too slow: your first guesses\nfor a hash probably require to read the whole board. Instead, a Zobrist hash is\nsimilar to a rolling hash, in that it only needs a single update to account for\nthe forward change.</p>\n<p>You start with a hash of zero for the blank board. When initializing the board,\nyou generate a random 64-bit value (or, when you are like me and use JS, a\n32-bit integer) for each intersection on the board, and for each move that can\nbe made on that position (place a black stone, or place a white stone).</p>\n<p>To compute the hash for a new board configuration, you take the hash of the\nprevious board. For every change on the board, you XOR the previous hash with\nthe random value associated with this particular change.</p>\n<p>For instance, if you place a black stone on A19 and it captures a white stone on\nB19, you will XOR the hash with the random value for “black A19”, and then XOR\nit with “white B19”. <em>Fun fact</em>: it yields the same value if you do it the other\nway around.</p>\n<h2>Score</h2>\n<p>The bulk of scoring is establishing territories. To make things simple, we\nassume the game went to its final conclusion, where there are no gray zones. All\nregions are either surrounded by white or black, and there are no capturable\nstones left.</p>\n<p>All that remains is to go through intersections in reading order, top to bottom,\nleft to right, and to stitch each empty spot to its neighbor territories,\npotentially joining two larger territories together if necessary. Any stone that\nis next to the territory gives it its color.</p>\n<p>It makes counting points fairly easy: add komi, capture, stones on board, and\nown territory, and the trick is done.</p>\n<h2>Ongoing</h2>\n<p>Having implemented the game rules is not enough to properly train bots on it.</p>\n<p>For starters, we need an <strong>SGF parser</strong> to extract information about the moves\nof existing games. SGF (Simple Game Format) is the main format for serializing\nGo games.</p>\n<p>Then, we want to support <strong>GTP</strong>: the Go Text Protocol is the most common format\nfor transmitting remote commands between a Go implementation and a robot player.</p>\n<p>Finally, we will explore various techniques for AI design.</p>\n<p>Expect fun!</p>\n<script type=\"application/ld+json\">\n{ \"@context\": \"http://schema.org\",\n  \"@type\": \"BlogPosting\",\n  \"datePublished\": \"2018-10-26T19:12:17Z\",\n  \"keywords\": \"baduk, ai\" }\n</script>\n",
      }
  ]
}
