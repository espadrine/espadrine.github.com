{
  "version": "https://jsonfeed.org/version/1",
  "title": "Espadrine’s blog",
  "description": "Let’s talk about whatever I learn!",
  "home_page_url": "https://espadrine.github.io/blog/",
  "feed_url": "https://espadrine.github.io/blog/feed.json",
  "author": {
    "name": "Thaddée Tyl",
    "url": "https://github.com/espadrine"
  },
  "favicon": "https://avatars.githubusercontent.com/u/100689?s=64",
  "items": [
      {
        "id":  "https://espadrine.github.io/blog/posts/file-system-object-storage.html",
        "url": "https://espadrine.github.io/blog/posts/file-system-object-storage.html",
        "title": "Insanities of a File System Object Storage",
        "tags": "storage posix",
        "date_published": "2018-05-31T19:42:00Z"
        "content_html": "<h1>Insanities of a File System Object Storage</h1>\n<p><em>(TL;DR: I present <a href=\"https://www.npmjs.com/package/fsos\">fsos</a>; but read on to know why.)</em></p>\n<p>How do you update a file in Node.js?</p>\n<p>Well, let’s browse our dear <a href=\"https://nodejs.org/api/fs.html\">file system API</a>…</p>\n<pre><code class=\"language-js\">fs.writeFile(file, data)\n</code></pre>\n<p>Simple enough, isn’t it?</p>\n<p>And yet, there are so many kinds of wrong in this seemingly obvious answer.</p>\n<h2>POSIX</h2>\n<p>Let’s first educate ourselves. Node.js’ file system API is designed to imitate\nand target POSIX, a specification to etch the core Unix experience in granite.\nWhile the main reason for the success of Unix was portability, ensuring that\nuserland programs could run on different machines, the three tenets of its\ndesign were also delicious (<strong>plain text</strong> as universal interface, composable\nprograms via a <strong>shell</strong>, and a <strong>hierarchical file system</strong> offering a unified\ninterface to kernel functionality (not just data storage)).</p>\n<p>Naturally, everybody stole those juicy ideas. When Richard Stallman famously\nchose to write a free operating system to oppose what we would today call DRM,\nhe wanted Unix compatibility. When compatibility is seeked, standardization\nbecomes necessary. IEEE sprung into action in the form of SUS (the Single Unix\nSpecification), and, with Richard’s suggested name, wrote the Portable Operating\nSystem Interface, <strong>POSIX</strong>.</p>\n<p>Richard’s baby, <strong>GNU</strong>, had little impact without a proper kernel. It was a\nmere collection of programs that would talk to a Unix file system if there was a\nfree one. Fortunately, a free one arose, birthed as <strong>Linux</strong>, and gained major\nadoption thanks to its sweet mix of speed, stability, and a healthy dose of\nbright experiments. When <strong>Node.js</strong> was created, Linux was the overwhelming\nking of the server-side, which Node.js wanted to conquer.</p>\n<p>In a way, the reason that the obvious one-liner above doesn’t work is Unix’\nfault. It designed file interaction in a manner that made a lot of sense for\nsome uses of the file system, disregarding others. Behind the covers, each\nfile is a mere set of contiguous disk space (blocks, extents, or sectors) that\npoint to each other, so it stands to reason that appending data at the end is\nprobably faster than appending it at the beginning, just as it is with a diary.</p>\n<p>The standard C library defined by POSIX reflects the internal design of Unix\nfile systems without hiding its flaws. Consequence: internally non-obvious\noperations have non-obvious solutions, and non-solutions that are as tempting to\nuse as a chocolate cookie (up until your tongue warns you that it was in fact\nraisins).</p>\n<p>The most critical interface for file operations is <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html\">open</a>. It returns a file\ndescriptor to operate the file. It takes a handful of required flags and a ton\nof optional ones. Most famous amongst the required ones are <code>O_RDONLY</code> if you\nwill only read, <code>O_WRONLY</code> if you don’t feel like reading anymore, and <code>O_RDWR</code>\nif you hate picking a side.</p>\n<p>Among the optional flags, <code>O_CREAT</code> creates the file automatically if it doesn’t\nexist, <code>O_TRUNC</code> empties the file, and <code>O_APPEND</code> forces you to write only at\nthe end. (What a coincidence that appending is both fast in file systems and\nhas a shortcut!)</p>\n<p>However, most people use <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/fopen.html\">fopen</a>, a layer on top of <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html\">open</a>, which\nunfortunately has very strange defaults. Instead of the flags we understand, it\nhas string modes that seem to mean something they do not do. Here are the\nnonsensical rules.</p>\n<ul>\n<li><code>&quot;r&quot;</code> is the only one that prevents writing,</li>\n<li>If the string has an <code>r</code>, it doesn’t create a file automatically,</li>\n<li>If the string does not have a <code>+</code>, it cannot both read and write,</li>\n<li>If the string has a <code>w</code>, it empties the file,</li>\n<li>If the string has an <code>a</code>, all writes append to the file (finally one that\ndoes what is on the cover!)</li>\n</ul>\n<p>For instance, <code>&quot;r+&quot;</code> can write, but won’t create a file automatically for some\nreason.</p>\n<p>The modes offered by <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/fopen.html\">fopen</a> barely target what people actually do with a\nfile:</p>\n<ol>\n<li>Read a configuration file: <code>&quot;r&quot;</code>,</li>\n<li>Write logs: <code>&quot;a&quot;</code>,</li>\n<li>Update a whole file: nothing.</li>\n</ol>\n<p>For more precise operations, use <code>&quot;r+&quot;</code>. All other possibilities are most likely\nbugs waiting to be found. Special mention to <code>&quot;w+&quot;</code> which empties the file it\nallows you to read! In fact, the main lesson of this blog post is that <code>O_TRUNC</code>\nhas only one, very rare, use-case: <em>emptying a file, without removing it,\nwithout writing to it</em>. You should essentially never use <code>&quot;w&quot;</code>.</p>\n<p>Naturally, Node.js favours <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/fopen.html\">fopen</a>-style modes, instead of the more elegant\n<a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html\">open</a>.</p>\n<p>Naturally, its default mode for write operations is the useless <code>&quot;w&quot;</code>.</p>\n<h2>Async IO</h2>\n<p>Now that we have background information, let’s dig into the first issue.</p>\n<p>A long-standing problem in HTTP server software is <a href=\"http://www.kegel.com/c10k.html\">C10K</a>, ie. hitting 10k\nconcurrent clients to serve with a single machine. A large part of beating that\nfigure is dealing with how slow IO is. Fetching a file on disk takes a long\ntime! And by default, POSIX system calls make your program wait for the file to\nbe read, and your program just sits there doing nothing in the meantime, like a\npassenger waiting for the bus to come.</p>\n<p>Fortunately, POSIX includes a special switch to avoid waiting: <code>O_NONBLOCK</code>. It\nis part of <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html\">open</a>. When an IO operation is performed, you can do whatever you\nwant, even though the operation is not done. Later on, you can call <code>poll()</code> or\n<code>select()</code> or <code>kqueue()</code> (depending on the OS you use), and learn whether the\noperation is done.</p>\n<p>Node.js’ <em>raison d’être</em> was completely focused on how easy JS makes\nasynchronous operations. Their whole file system interface recommends using the\nnon-blocking API. But in some cases, it makes zero sense. So it is with\n<code>fs.writeFile()</code>. It <em>never</em> does what you want. Not with the default\nparameters, anyway.</p>\n<p>When you use storage, you implicitly expect some level of consistency. If you\nwrite ‘hello’ to a file which contains ‘hi’ and then immediately read from it,\nyou don’t expect to read ‘who is this?’ if absolutely nobody wrote to the file\nin the meantime. You expect ‘hello’ — or, at least, ‘hi’. But here, you will\nread neither what was in the file before, nor what you wrote in it.</p>\n<pre><code class=\"language-js\">var fs = require('fs')\nvar fn = './foo'  // file name\nfs.writeFileSync(fn, '1234\\n')\nfs.createReadStream(fn).pipe(process.stdout)  // → 1234\nfs.writeFile(fn, '2345\\n')\nfs.createReadStream(fn).pipe(process.stdout)  // The file is empty.\n</code></pre>\n<p>This is the code I submitted as <a href=\"https://github.com/nodejs/node-v0.x-archive/issues/7807\">an issue</a> to Joyent’s node (prior to\nthe io.js fork).</p>\n<p>So what is going on? Why does it break your implicit consistency expectations?\nIt turns out that the operations you use are not atomic. What <code>fs.writeFile()</code>\nreally means is “Empty the file immediately, and some day, please fill it with\nthis.” In POSIX terms, you perform an\n<code>open(…, O_WRONLY|O_CREAT|O_TRUNC|O_NONBLOCK)</code>, and the <code>O_TRUNC</code> empties the\nfile. Since it is <code>O_NONBLOCK</code>, the next line of code gets executed immediately.\nThen, Node.js’ event loop spins: on the next tick, it polls, and the file system\ntells it that it is done (and indeed, it is). Note that it can take many more\nevent loop ticks, if there is a larger amount of data written.</p>\n<p>Fundamentally, why would you ever want those default flags (aka. <code>fopen</code>’s\n<code>'w'</code>)? If you are writing logs or uploading a file to the server, you want\n<code>'a'</code> instead; if you are updating configuration files or any type of data, you\nwant… something that will be described in the next chapter. For any type of file\nthat has the risk of being read, this default flag is the wrong one to use.</p>\n<p>So, the problem is that it was non-blocking, right? After all, if we change it\nto be synchronous, it all seems to work, right?</p>\n<pre><code class=\"language-js\">var fs = require('fs')\nvar fn = './foo'  // file name\nfs.writeFileSync(fn, '1234\\n')\nfs.createReadStream(fn).pipe(process.stdout)  // → 1234\nfs.writeFileSync(fn, '2345\\n')\nfs.createReadStream(fn).pipe(process.stdout)  // → 2345\n</code></pre>\n<p>Don’t you hate it when you read a blog post, and the author ends two\nconsecutive sentences with “right?”, and you just know it means “false!”</p>\n<h2>File Systems</h2>\n<p>What if your application crashes?</p>\n<p>Having your app crash just after you opened the file for writing, but before it\nis done writing, will unsurprisingly result in a half-written file — or an empty\none. Since the memory of the crashed app is reclaimed, the data that was not\nwritten is lost forever!</p>\n<p>You want to <em>replace a file</em>. Therefore, even if the application crashes, you\nwant to make sure that you maintain either the old version, or the new version,\nbut not an in-between. <code>fs.writeFileSync()</code> does not offer that guarantee, just\nas the underlying POSIX primitives. It is tempting, but wrong.</p>\n<p>In <a href=\"http://thunk.org/tytso/blog/2009/03/12/delayed-allocation-and-the-zero-length-file-problem/comment-page-5/#comment-2782\">the words</a> of Theodore Ts’o, maintainer of ext4, the most used\nfile system on Linux and possibly in the world (and creator of <code>/dev/random</code>):</p>\n<blockquote>\n<p>Unfortunately, there very many application programmers that attempt to update an existing file’s contents by opening it with O_TRUNC. I have argued that those application programs are broken, but the problem is that the application programmers are “aggressively ignorant”, and they outnumber those of us who are file system programmers.</p>\n</blockquote>\n<p>The fundamental issue is that <code>fs.writeFileSync()</code> is not atomic. It is a series\nof operations, the first of which deletes the old version of the file, the next\nones slowly inserting the new version.</p>\n<p>What do we want? The new version! When do we want it? Once written on disk,\nobviously. We have to first write the new version on disk, alongside the old\none, and then switch them. Fortunately, POSIX offers a primitive that performs\nthat switch <em>atomically</em>. World, meet <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/rename.html\"><code>rename()</code></a>.</p>\n<pre><code class=\"language-js\">var tmpId = 0\nvar tmpName = () =&gt; String(tmpId++)\nvar replaceFile = (file, data, cb) =&gt; {\n  var tmp = tmpName()\n  fs.writeFile(tmp, data, err =&gt; {\n    if (err != null) { cb(err); return }\n    fs.rename(tmp, file, cb)\n  })\n}\n</code></pre>\n<p>Obviously, I simplify a few things in this implementation:</p>\n<ul>\n<li>We have to verify that the <code>tmp</code> file does not exist,</li>\n<li>We should make <code>tmp</code> have a UUID to reduce the risk that another process\ncreates a file with the same name between the moment we check for its\nexistence and the moment we write to it,</li>\n<li>We said before that Node.js was using <code>'w'</code> as the default write flag; we want\nto use at least <code>'wx'</code> instead. <code>x</code> is a Node.js invention that uses <code>O_EXCL</code>\ninstead of <code>O_TRUNC</code>, so that the operation fails if the file already exists\n(we would then retry with a different UUID),</li>\n<li>We need to create <code>tmp</code> with the same permissions as <code>file</code>, so we also need\nto <code>fs.stat()</code> it first.</li>\n</ul>\n<p>All in all, the finished implementation is nontrival. But this is it, right?\nThis is the end of our ordeal, right? We finally maintained consistency, right?</p>\n<p>I have good news! According to POSIX, yes, this is the best we can do!</p>\n<h2>Kernel Panics</h2>\n<p>We settled that <em>write temporary then rename</em> survives app crashes under\nPOSIX. However, there is no guarantee for system crashes! In fact, POSIX gives\nabsolutely no way to maintain consistency across system crashes with certainty!</p>\n<p>Did you really think that being correct according to POSIX was enough?</p>\n<p>When Linux used ext2 or ext3, app developers used <em>truncate then write</em> or the\nslightly better <em>write temporary then rename</em>, and everything seemed fine,\nbecause system crashes are rare. Then a combination of three things happened:</p>\n<ul>\n<li>Unlike ext3, ext4 was developed with <strong>delayed allocation</strong>: writes are\nperformed in RAM, then it waits for a few seconds, and only then does it apply\nthe changes to disk. It is great for performance when apps write too often.</li>\n<li>GPU vendors started writing drivers for Linux. Either they didn’t care much\nabout their Linux userbase, or all their drivers are faulty: the case remains\nthat <strong>those drivers crashed a lot</strong>. And yet, the drivers are part of the\nkernel: they cause system crashes, not recoverable application crashes.</li>\n<li><strong>Desktop Linux</strong> users started playing games.</li>\n</ul>\n<p>What had to happen, happened: a user played a game that crashed the system, at\nwhich point all files that had been updated in the past 5 seconds were zeroed\nout. Upon reboot, the user had lost a lot of data.</p>\n<p>There were a lot of sad Linux users and grinding of teeth. As a result, Theodore\nTs’o <a href=\"http://thunk.org/tytso/blog/2009/03/12/delayed-allocation-and-the-zero-length-file-problem/\">patched</a> the kernel to detect when apps update files\nthe wrong way (ie, both <em>truncate then write</em> and <em>write temporary then\nrename</em>), and disabled delayed allocation in those cases.</p>\n<p>Yes. <em>Write temporary then rename</em> is also the wrong way to update a file. I\nknow, it is what I just advised in the previous section! In fact, while POSIX\nhas no way to guarantee consistency for file updates, here is the closest thing\nyou’ll get:</p>\n<ol>\n<li>Read the file’s permissions.</li>\n<li>Create a temporary file in the same directory, with the same permissions,\nusing <code>O_WRONLY</code>, <code>O_CREAT</code> and <code>O_EXCL</code>.</li>\n<li>Write to the new file.</li>\n<li><a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/fsync.html\"><code>fsync()</code></a> that file.</li>\n<li>Rename the file over the file you want to update.</li>\n<li><code>fsync()</code> the file’s directory.</li>\n</ol>\n<p>Isn’t it <a href=\"http://thunk.org/tytso/blog/2009/03/15/dont-fear-the-fsync/\">obvious</a> in retrospect?</p>\n<p><em>Renaming the file before it is <code>fsync</code>’ed</em> creates a window of time where a\ncrash would make the directory point to the updated file, which isn’t committed\nto disk yet (as it was in the file system cache), and so the file is empty or\ncorrupt.</p>\n<p>Less harmful, <em>a crash after renaming and before the directory’s cache is\nwritten to disk</em> would make it point to the location of the old content. It\ndoesn’t break atomicity, but if you only want to perform some action after the\nfile was replaced <em>for sure</em>, you would better <code>fsync</code> that directory before you\ndo something you will regret. It might seem like nothing, but it can break your\nassumptions of data consistency.</p>\n<p>If you own an acute sense of observation, you noticed that, while Theodore’s\npatch makes it less likely that “badly written file updates” will cause files to\nbe zeroed out upon a system crash, the bug always existed and still exists! The\ntimespan where things can go horribly wrong is only reduced. The fault is\nrejected on the app developers.</p>\n<p>This issue was “fixed” — well, the patch landed at least — in Linux 2.6.30 on\nthe most common file systems (ext4 and btrfs).</p>\n<h2>Conclusion</h2>\n<p>Here’s one thing to get away from all this: file systems have a design which\nworks well with certain operations and… not so well… with others. <strong>Replacing a\nfile is costly!</strong> You should know what you are doing (or use <a href=\"https://www.npmjs.com/package/fsos\">fsos</a>, my npm\nlibrary which wraps all of this in sweet promises), and only replace files at\nworst a few times a second. Ideally a lot less often, especially for large\nfiles.</p>\n<p>Realistically, though, what you fundamentally want is not to lose work that is\nolder than X seconds, for some value of X that is thankfully often larger than\na half.</p>\n<p>Besides, this is Node.js. One issue that is common elsewhere with a trivial\nimplementation is that the main thread waits for the I/O to be finished before\nit can move on. In Node.js, we get asynchrony for free. The file replacement\nhappens essentially in the background. The main thread stays as responsive as a\nhappy antelope!</p>\n<p>PS: I feel like I should also advocate for a few things. For every mistake,\nthere is both a lesson and a prevention; we have only just learned the lesson.\nProgrammers go to the path of least resistance, and what they face encourages\nthem to the pit of death. I see two splinters to remove:</p>\n<ol>\n<li>Linux should offer an atomic file replacement operation that does it all\nright. Theodore argues that it is glib’s (and other libraries’) task, but I\ndisagree. To me, one of the most common file operations doesn’t have its\nsyscall.</li>\n<li>Node.js’ defaults ought to be improved. <code>fs.writeFile()</code> heavily suggests\nbeing used for file updates, and has the default flag of <code>'w'</code>. It is a terribly\nill-advised primitive for any use. It should be replaced by <code>'ax'</code>, but it\ncannot, because of legacy! I recommend having a warning, and a separate\n<code>fs.updateFile()</code> function.</li>\n</ol>\n<script type=\"application/ld+json\">\n{ \"@context\": \"http://schema.org\",\n  \"@type\": \"BlogPosting\",\n  \"datePublished\": \"2018-05-31T19:42:00Z\",\n  \"keywords\": \"storage, posix\" }\n</script>\n",
      },
      {
        "id":  "https://espadrine.github.io/blog/posts/thefiletree-design-log-4.html",
        "url": "https://espadrine.github.io/blog/posts/thefiletree-design-log-4.html",
        "title": "TheFileTree Design Log 4: Accounts",
        "tags": "tree",
        "date_published": "2018-03-01T23:19:58Z"
        "content_html": "<h1>TheFileTree Design Log 4: Accounts</h1>\n<p>I mentionned needing to add accounts in <a href=\"./thefiletree-design-log-2.html\">design log 2</a>. It is <a href=\"https://github.com/garden/tree/commit/04a03786d81733aeca35b1ac4fe5b95c57d0e706\">now implemented</a>.</p>\n<p>You go to <code>/app/account/</code>, which contains either your account information if you are logged in, or a form to get registered.</p>\n<p><img src=\"https://i.imgur.com/rlfES3K.png\" alt=\"Create an Account\" /></p>\n<p><img src=\"https://i.imgur.com/5oZdUdH.png\" alt=\"Congratulations for signing up\" /></p>\n<p>You get an email with a link back to the website, which gives you a httpOnly secure cookie with a token that the database will recognize and associate to a JSON blob containing your information (email, user name).</p>\n<p><img src=\"https://i.imgur.com/mWxce40.png\" alt=\"Email with link\" /></p>\n<p><img src=\"https://i.imgur.com/bNBGooa.png\" alt=\"Welcome page\" /></p>\n<p><img src=\"https://i.imgur.com/Pw4thNV.png\" alt=\"Account page\" /></p>\n<p>As planned, I use email-login, which I improved for this purpose by adding support for <a href=\"https://www.cockroachlabs.com/\">CockroachDB</a>, a serializable distributed SQL database that I plan on using more (maybe for file metadata).</p>\n<p>All files <a href=\"https://github.com/garden/tree/commit/6fbe24c41dfa7085533a6a0157daefc5a28ed7a4\">now</a> have an Access Control List (ACL) so that you can set the default access (none (404), reader, writer (can see and edit), owner (can also change the metadata, and therefore the ACL).</p>\n<p><img src=\"https://i.imgur.com/2lROKuf.png\" alt=\"Folder ownership\" /></p>\n<p>ACLs on folders apply to all subfiles unless an explicit ACL overrides it. It works like variable scoping: the nearest containing metafolder with an explicit ACL that applies to you determines your access.</p>\n<p>It works by setting the <code>acl</code> JSON object in the metadata. It is a map from username to right: <code>-</code> for none, <code>r</code> for reader, <code>w</code> for writer, <code>x</code> for owner.  Does it remind you of Unix permissions?</p>\n<p><img src=\"https://i.imgur.com/c04V9J9.png\" alt=\"JSON metadata\" /></p>\n<p>The <code>*</code> key is for other users (logged in or anonymous).</p>\n<h2>Canop Finishing Touches</h2>\n<p>Code and bugs are lovers. The monster that I am had to crush a handful of the latter, but it really was to save the former.</p>\n<p>For instance, <strong>undo/redo</strong> was semantically wrong.</p>\n<p>Why? Of course, CodeMirror supports undo/redo, but it keeps track of all changes. However, when you are editing code with others, you only want to undo <em>your own changes</em>. If you wrote a word and press <em>Undo</em>, you expect your word to be removed, not the operations that someone else did in the meantime.</p>\n<p>That required <a href=\"https://github.com/espadrine/canop/commit/ed07dc80f8da61da15dee0703893315b1f863ba6\">managing my own undo stack</a></p>\n<p>Another tricky situation arose while testing when I started using <strong>multiple cursors</strong>, a feature that every text editor under the sun stole from <a href=\"https://www.sublimetext.com/docs/2/multiple_selection_with_the_keyboard.html\">SublimeText</a> (although Wikipedia <a href=\"https://en.wikipedia.org/wiki/Simultaneous_editing\">mentions</a> MIT’s <a href=\"https://en.wikipedia.org/wiki/Simultaneous_editing\">LAPIS</a> as the first to sport it, as part of their academic paper.)</p>\n<p>I received the editing operations CodeMirror gave me from the <code>change</code> events after it had already updated the editor. The operation positions I dealt with could not easily be mapped back to indices, as they related to the editor’s state before the change.</p>\n<p>I tried getting inspiration from <a href=\"https://github.com/Operational-Transformation/ot.js/blob/8873b7e28e83f9adbf6c3a28ec639c9151a838ae/lib/codemirror-adapter.js#L55\">ot.js</a>, but ended up relying on a <a href=\"https://github.com/espadrine/canop/commit/1bc109bfc6b075b1a59d4e2401f902edfdf8288a\">simpler algorithm using the <code>beforeChange</code> event</a>.</p>\n<p>It does have the downside that you don’t automatically have multiple changes that are semantically combined (like deleting multiple selections). Those end up having a single undo entry, for instance. I was getting used to reimplementing CodeMirror things, so naturally I implemented a <a href=\"https://github.com/espadrine/canop/commit/7beec5d1b8e231e0a52c6402931d5db77c2491da\">time-based operation grouping system</a>.</p>\n<h2>Deploying To Production</h2>\n<p>The first version of TheFileTree was located on a server under our college\ndormroom desks; the second in a college server; the third on a friend’s\nsubletting server offer; the fourth on an OVH VPS. This one will be on Google\nCloud, starting with their free tier, where it should fit for some time before\nit, hopefully starts generating revenue to be self-sustaining.</p>\n<p>It did require some subtle tweaking to support the fact that sending emails is\nseverely restricted on Google Cloud. There is a handful of partners that you\nhave to go through; I picked MailJet. I tweaked the <code>email-login</code> npm package\nand my DNS zone file to make it work.</p>\n<p>As far as administrator interfaces are concerned, Google Cloud is extremely\npolished, offering a clean interface with good configuration, and even a\nconvenient remote SSH-in-a-tab.</p>\n<p>While it is still slightly slower to get up and running with a fresh instance\nthan on Digital Ocean, it is a step up from OVH. That said, OVH offers a\npredictable fixed cost and no egress cost, while GCP will have complicated costs\nto manage once I need to look after them.</p>\n<p>Sadly, to get on the free tier, I was required to host the servers in South\nCarolina, US. There is a subtle bit more latency as a result from France.</p>\n<p>All in all, it was a very interesting choice to have. The website is now much\nmore robust than it was before. The only dark spot is the single-node\nCockroachDB server, which dies on a regular basis, seemingly because it does not\nlike to be alone. I will have to investigate further later.</p>\n<script type=\"application/ld+json\">\n{ \"@context\": \"http://schema.org\",\n  \"@type\": \"BlogPosting\",\n  \"datePublished\": \"2018-03-01T23:19:58Z\",\n  \"keywords\": \"tree\" }\n</script>\n",
      },
      {
        "id":  "https://espadrine.github.io/blog/posts/what-i-built-in-2017.html",
        "url": "https://espadrine.github.io/blog/posts/what-i-built-in-2017.html",
        "title": "What I Made In 2017",
        "tags": "retro",
        "date_published": "2018-02-23T21:37:12Z"
        "content_html": "<h1>What I Made In 2017</h1>\n<p>After some time working on the collaboration between <a href=\"https://trainline.eu\">Captain Train</a> and its\nacquirer <a href=\"https://www.thetrainline.com\">Trainline</a>, to bring together both companies’ technologies through a\ncommon protocol, and maintaining the SNCF integration through major evolutions\nof their offerings, I left the company to join <a href=\"https://qonto.eu\">Qonto</a></p>\n<p>This bank startup that just came out of beta when I joined (I literally removed\nthe beta tag from the website on my first week) offers the most streamlined\nonline banking experience for businesses.</p>\n<p>I brought together a great team. This year, we will focus on making the backend\nbanking integration top-notch.</p>\n<p>As a result, I had less time for free-time open-source. There were three big\ndirections to what I did:</p>\n<ul>\n<li>The <a href=\"https://shields.io\">Shields.io</a> core team increased, and it allowed us to optimize things\nlike the <a href=\"https://github.com/badges/shields/pull/1390\">font-width computation</a> (hat tip to Paul Melnikow for that).</li>\n<li>I pursue <a href=\"https://thefiletree.com\">TheFileTree</a>, to provide the infrastructure for a self-helping\ncommunity of makers. (It is very far from there yet.) I switched it to using\nthe <a href=\"https://github.com/espadrine/canop\">Canop</a> system, which I still have to make support a full JSON, to allow\nfor more complex apps. I redid the API and made the app system as designed\nthe year before.</li>\n<li>I played with AI in the stride of DeepMind’s [AlphaGo][] effort, and produced\na Node.js Go library, <a href=\"https://github.com/espadrine/badukjs\">badukjs</a>.</li>\n</ul>\n<p>To sum up, this year, I switched focus from “me” to “us”. Great things are not a\nlonely job, but an active coordination.</p>\n<p>Next year, I will focus on building-block infrastructure for more cooperation.</p>\n<p><a href=\"http://espadrine.github.io/blog/posts/what-i-made-in-2016.html\">Previously</a>.</p>\n<script type=\"application/ld+json\">\n{ \"@context\": \"http://schema.org\",\n  \"@type\": \"BlogPosting\",\n  \"datePublished\": \"2018-02-23T21:37:12Z\",\n  \"keywords\": \"retro\" }\n</script>\n",
      },
      {
        "id":  "https://espadrine.github.io/blog/posts/what-i-made-in-2016.html",
        "url": "https://espadrine.github.io/blog/posts/what-i-made-in-2016.html",
        "title": "What I Made In 2016",
        "tags": "retro",
        "date_published": "2017-06-16T20:12:00Z"
        "content_html": "<h1>What I Made In 2016</h1>\n<p>This year, the company I work for, Captain Train, was purchased by its English counterpart, Trainline. I added support for American Express BTA lodged cards, upgraded the SNCF integration to support their new fare systems, and worked on the common format for carriers.</p>\n<p>In open-source, I made the following.</p>\n<ul>\n<li>A natural-language-processing bot library <a href=\"https://github.com/espadrine/queread\">queread</a>, in order to power <a href=\"https://github.com/espadrine/travelbot\">travelbot</a>, a CLI and Slack bot system which you can ask for travel information across Europe. It uses <a href=\"https://github.com/espadrine/travel-scrapper\">travel-scrapper</a>, which relies on the Trainline websites for data.</li>\n<li>A multiplayer musical editor on top of TheFileTree, as a flexible textual editor. See <a href=\"https://thefiletree.com/david/audio/test.abc\">this example</a>.</li>\n<li><a href=\"https://github.com/espadrine/email-login\">Email-Login</a> is now robust and ready to use.</li>\n<li><a href=\"https://espadrine.github.io/spash/\">Spash</a>, a <a href=\"https://en.wikipedia.org/wiki/Geohash\">geohash</a>-inspired Spacetime locator.</li>\n<li>The <a href=\"https://github.com/espadrine/json-diff\">json-diff</a> gem offers a brand-new algorithm for diffing JSON content, with support for in-array object move operations as a first-class citizen, unlike existing LCS-based approaches, resulting in better output. I even published a <a href=\"https://engineering.thetrainline.com/2016/10/05/how-we-switched-without-a-hitch-to-a-new-api/\">blog post</a> on Trainline’s blog.</li>\n<li>The <a href=\"https://github.com/espadrine/json-api-vanilla\">json-api-vanilla</a> gem parses <a href=\"http://jsonapi.org/\">JSONAPI</a> payloads (ie. JSON with references, to support object graphs with reference cycles, etc.) and converts it to vanilla Ruby objects, with references correctly hooked up, without <em>any class definition needed</em>, unlike what existed before that.</li>\n<li>The <a href=\"https://github.com/espadrine/canop/blob/master/doc/protocol.md\">Canop protocol</a> was finalized and implemented. <a href=\"https://github.com/espadrine/canop/commit/b0f37b2cc789513e9c8bd1986e113bed6580328f\">This commit</a> in particular finally implemented proper index shifting for intention preservation, so that people can edit the same text file simultaneously without losing their changes.</li>\n<li>The <a href=\"https://github.com/espadrine/json-sync\">json-sync</a> project sprung out of the Canop effort. Unlike Canop, it cannot yet perform intention preservation. However, its design supports peer-to-peer networks, unlike Canop which is centralized.</li>\n</ul>\n<p>I took greater concern in explaining my projects. People wouldn’t understand the schematics for the first automobile, but a simple demonstration is enough to blow everybody’s mind.</p>\n<p><a href=\"http://espadrine.tumblr.com/post/138229350686/what-i-did-in-2015\">Previously</a>.</p>\n<script type=\"application/ld+json\">\n{ \"@context\": \"http://schema.org\",\n  \"@type\": \"BlogPosting\",\n  \"datePublished\": \"2017-06-16T20:12:00Z\",\n  \"keywords\": \"retro\" }\n</script>\n",
      },
      {
        "id":  "https://espadrine.github.io/blog/posts/a-go-browser-battle.html",
        "url": "https://espadrine.github.io/blog/posts/a-go-browser-battle.html",
        "title": "A Go Browser Battle",
        "tags": "baduk ai",
        "date_published": "2017-06-16T16:53:49Z"
        "content_html": "<h1>A Go Browser Battle</h1>\n<p>I learned Go from my Dad — after all, we lived in Japan for a short while when I was little — but DeepMind’s <a href=\"https://events.google.com/alphago2017/\">foray</a> into the venerable board game definitely renewed my interest.</p>\n<p>My friend <a href=\"https://github.com/jankeromnes/\">Jan</a>, also intrigued, had started working on a browser-based interface to play the game.</p>\n<p>So I offered him a playful challenge: we would both try to build an interesting AI for the game, and we would pit them against each other.\nEach AI would be in a separate <a href=\"https://html.spec.whatwg.org/multipage/workers.html#workers\">WebWorker</a>.\nAt each turn, they would receive the board state.\nThey would have one minute to come up with their move, in a best-of-five tournament.</p>\n<p>From what he told me, Jan will be trying to brute-force the search tree with a traditional minimax.\nHe is betting on a smart and fast board evaluation.</p>\n<p>As for me, I started studying the <a href=\"https://storage.googleapis.com/deepmind-media/alphago/AlphaGoNaturePaper.pdf\">AlphaGo Nature paper</a>.\nI took machine learning classes at University; time to apply what I learned!</p>\n<p>I definitely don’t have the computing power or the time to reach the level that AlphaGo achieved.\nIt took months of training and self-play on tens of GPUs and hundreds of CPUs.\nMy dream is to reach 1d; a rank roughly equivalent to a black belt in martial arts.</p>\n<h2>Stepping Stones</h2>\n<p>Go games are typically saved as <a href=\"http://www.red-bean.com/sgf/\">SGF</a> files, which are plentiful on the Web.\nTherefore, the first step I needed to achieve was to have an SGF parser and a Go execution engine.\nThe engine is designed to give me a wealth of information about the game: what group is a stone part of, how many liberties that group has…</p>\n<p><img src=\"https://thefiletree.com/metaboard/go/blog/intro/print-sgf.png\" alt=\"SGF printer output\" /></p>\n<p>I downloaded all KGS games involving players that are 4d or above.\nI hope my design achieves 1d, so in principle, the AI will never reach that level of play.</p>\n<p>Aside: I think it is interesting to think about learning in terms of <em>training capacity</em> and <em>model capacity</em>.\nHere, since we learn to mimick the moves of the training set, the AI can only be as smart as the training set, which puts a limit to how intelligent it can be.\nBut the model itself can achieve a superior level through self-play (which is what DeepMind did, obviously, since they reached a level beyond the top human player). Then, the level they can achieve is that of the model capacity.\nAn entity able to perfectly analyse all possible futures would have the highest possible model capacity.</p>\n<p>The KGS dataset represents 1.7 million games.\nAfter rotating and reflecting each game, I should reach 13.5 million games, which should be enough to teach the neural network.</p>\n<p><img src=\"https://thefiletree.com/metaboard/go/blog/intro/badukjs.png\" alt=\"6.5 GB of downloaded KGS SGF files\" /></p>\n<p>Just like AlphaGo, I will first train a <strong>move guesser</strong> using a convolutional neural network.\nThat network reads the board through a hundred lenses called “filters” that focus on 3x3 squares (or 5x5 on the first layer).\nEach lens annotates every intersection with an analysis of its surroundings.\nThe annotated board is given as input to a different set of lenses, and so on, ten times.\nThe last annotated board rates the moves with how likely KGS players are to make them.</p>\n<p>The move guesser can be used standalone, although I don’t expect it to perform well.\nIts main purpose is to limit the number of moves you will look at on the search tree.\nExpanding too many nodes can really make your AI lose precious time.</p>\n<p>I also want to train a <strong>win guesser</strong>. It is another convolutional neural network.\nInstead of yielding likely moves, it will tell you who it thinks will win.</p>\n<p>While AlphaGo trained its win guesser from self-play games which also improved its move guesser, I am unsure whether I will have enough time to implement self-play tournaments.\nBut having a win guesser learn from the KGS data set is possible; it simply might yield poor results.</p>\n<p>Finally, if I have time to spare, I may implement <strong>Monte-Carlo Tree Search</strong> (<a href=\"https://en.wikipedia.org/wiki/Monte-Carlo_Tree_Search\">MCTS</a>).\nIt requires having a very fast move guesser (not the 10-layer monster).\nAlphaGo trained a shallower neural network for that purpose, feeding it, in addition to the board state, whether a given move matches a set of well-known patterns.\nThe paper claims it guesses about 24% of moves from their data set, at a meager 2 μs.</p>\n<p>For this purpose, I am tempted to perform some custom statistical analysis on the training data.\nYet again, it depends on what that yields, and how much time I have.</p>\n<p>MCTS works by repeating the following steps:</p>\n<ol>\n<li>walk the tree through what is currently the best move,</li>\n<li>without adding nodes to the search tree, play with the weak move guesser until the end of the game,</li>\n<li>update the node’s ancestors in the search tree to count the number of wins and losses, which may change what is the best move.</li>\n</ol>\n<p>When a node is walked through enough times, it gets expanded with the strong move guesser.</p>\n<h2>Into The Browser</h2>\n<p>I plan on training the networks in Python with <a href=\"https://keras.io/\">Keras</a>, which will use <a href=\"https://www.tensorflow.org\">TensorFlow</a> to benefit from its optimized C++ engine.\nI own a desktop computer that unfortunately features a weak-ish Nvidia GPU, but it will have to do!</p>\n<p>Keras is fast becoming the standard API to train and export neural nets; Microsoft recently touted its support as a front-end for <a href=\"https://www.microsoft.com/en-us/cognitive-toolkit/\">CNTK</a> when they unveiled <a href=\"https://docs.microsoft.com/en-us/cognitive-toolkit/ReleaseNotes/CNTK_2_0_Release_Notes\">version 2</a> of the library.\nInevitably, there are a couple libraries to convert Keras models to JavaScript.\n<a href=\"https://github.com/transcranial/keras-js\">Keras.js</a> most notably features GPU support, but using the GPU in a <a href=\"https://html.spec.whatwg.org/multipage/workers.html#workers\">WebWorker</a> is not yet possible.\nMaybe when all browsers implement <a href=\"https://html.spec.whatwg.org/multipage/scripting.html#the-offscreencanvas-interface\">OffscreenCanvas</a> and Keras.js <a href=\"https://github.com/transcranial/keras-js/issues/3\">implements support for it</a>?</p>\n<p>And there’s <a href=\"https://mil-tokyo.github.io/webdnn/\">WebDNN</a>, which I will use.</p>\n<p>WebDNN is fastest when using <a href=\"https://webkit.org/blog/7504/webgpu-prototype-and-demos/\">WebGPU</a>, a standard that I hope will get traction, but that is currently Safari-only.\nHowever, it can compile the neural network to <a href=\"http://webassembly.org/\">WebAssembly</a>, which should fit in a <a href=\"https://html.spec.whatwg.org/multipage/workers.html#workers\">WebWorker</a>.</p>\n<h2>Dreams and Work</h2>\n<p>This will all be a free-time effort.\nThere is no planned date for the final confrontation.</p>\n<p>The code for the SGF parser, Go engine, and AIs will be <a href=\"https://github.com/espadrine/badukjs\">here</a>, and the UI code will be <a href=\"https://github.com/jankeromnes/metaboard\">there</a>.</p>\n<script type=\"application/ld+json\">\n{ \"@context\": \"http://schema.org\",\n  \"@type\": \"BlogPosting\",\n  \"datePublished\": \"2017-06-16T16:53:49Z\",\n  \"keywords\": \"baduk, ai\" }\n</script>\n",
      }
  ]
}
